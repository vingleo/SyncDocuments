Fundamentals of DevOps and Software Delivery 


Preface
前言

There are many guides out there on how to write software.
市面上有很多关于如何编写软件的指南。

This book is a guide to software delivery—that is, all the processes, tools, and techniques that are required to run and maintain software in production on an ongoing basis.In particular, this book is a guide to DevOps, a methodology for making software delivery more efficient.
本书是一本软件交付指南——它涵盖了在生产环境中持续运行和维护软件所需的所有流程、工具和技术。具体来说，本书是一本 DevOps 指南，DevOps 是一种提高软件交付效率的方法论。


Whereas most books and talks on DevOps focus on culture, values, and organizational structure, I’ve found that when most people talk about DevOps, what they are really interested in is the mechanics of effective software delivery. That’s what this book is all about. It’s a hands-on guide that includes dozens of step-by-step examples of how to run production systems. You’ll start with the basics—an app running on a single server—and work your way up to microservices in a Kubernetes cluster with a service mesh, automated deployment pipeline, end-to-end encryption, and more.
虽然大多数关于 DevOps 的书籍和演讲都侧重于文化、价值观和组织结构，但我发现，当大多数人谈论 DevOps 时，他们真正感兴趣的是高效软件交付的机制。这正是本书的核心所在。这是一本实战指南，包含数十个关于如何运行生产系统的分步示例。您将从基础知识入手——例如在单台服务器上运行的应用程序——逐步深入到 Kubernetes 集群中的微服务架构，包括服务网格、自动化部署流水线、端到端加密等等。

By the time you’re done with the book, you will have had hands-on practice with all the core concepts and practices of modern DevOps and software delivery, including:
读完本书后，你将对现代 DevOps 和软件交付的所有核心概念和实践进行实际操作，包括：

● Deploying VMs (EC2), containers (Kubernetes), and serverless apps (Lambda)
● 部署虚拟机 (EC2)、容器 (Kubernetes) 和无服务器应用 (Lambda)

● Managing your infrastructure as code via OpenTofu,　Packer, and Ansible
● 通过 OpenTofu、Packer 和 Ansible 以代码形式管理您的基础设施

● Automating your builds, tests, and deployments in a　CI/CD pipeline
● 在 CI/CD 流水线中自动化您的构建、测试和部署

● Configuring networking, including VPCs, VPNs,DNS, and service meshes
● 配置网络，包括 VPC、VPN、DNS 和服务网格

● Splitting your codebase into multiple environments,　libraries, and microservices
● 将您的代码库拆分为多个环境、库和微服务

● Managing secrets and encrypting data in transit　(TLS) and at rest (AES)
● 管理密钥并对传输中 (TLS) 和静态 (AES) 数据进行加密

● Storing data in relational databases, NoSQL　databases, and file stores
● 将数据存储在关系数据库、NoSQL 数据库和文件存储中

● Setting up monitoring, including metrics, logs, events, and alerts
● 设置监控，包括指标、日志、事件和警报

● And much more!
● 以及更多！

Before jumping into all this content, I want to take a moment to talk about why I felt the need to write this book —and why you may want to read it.
在深入探讨本书内容之前，我想花点时间谈谈我为什么觉得有必要写这本书——以及为什么你可能想读这本书。

Why I Wrote This Book
我为什么写这本书

Almost every piece of software depends on software
delivery practices for deployment, maintenance, and security. And yet, I’m not aware of any hands-on guides that teach software delivery end to end. Just about everyone who learns software delivery today is learning it the hard way, through trial and error. Unfortunately, errors in software delivery can be costly: they result in outages, data loss, and security breaches. The lack of a good way to learn software delivery is making the entire software industry slower, less effective, and less secure.
几乎所有软件的部署、维护和安全都依赖于软件交付实践。然而，我却从未见过任何一本提供端到端软件交付实战指导的指南。如今，几乎所有学习软件交付的人都是通过反复试错来摸索的。不幸的是，软件交付中的错误代价高昂：会导致系统宕机、数据丢失和安全漏洞。缺乏有效的软件交付学习方法，使得整个软件行业效率降低、运行缓慢且安全性下降。

I experienced this firsthand. In 2011, I was working at LinkedIn. From the outside, everything looked great: the company had just had its initial public offering (IPO), the share price was up by over 100%, revenue was growing by more than 100% year over year, and the website had over 100 million members, with 2 new members joining every single second. But from the inside, the company was in turmoil. Why? Because our software delivery practices had gotten so bad that we could no longer deploy.
我对此深有体会。2011年，我在LinkedIn工作。从表面上看，一切都很美好：公司刚刚完成首次公开募股（IPO），股价上涨超过100%，收入同比增长超过100%，网站拥有超过1亿会员，平均每秒新增2名会员。但实际上，公司内部却一片混乱。为什么呢？因为我们的软件交付流程已经糟糕到无法部署的地步。

Back then, we would do deployments once every two weeks, and it was always a painful, tedious, and errorprone affair. In 2011, we had a deployment that went so badly we couldn’t complete it, no matter how hard we tried. We rolled out some new changes, which caused system instability; we pushed some fixes, but those caused new bugs; we pushed more fixes, but that only led to more issues. Teams worked through the night, into the next day, and we still couldn’t get things stable. In the end, after a several-day deployment nightmare, we had to roll everything back.
那时，我们每两周部署一次，每次都是痛苦、繁琐且容易出错的。2011 年，我们的一次部署彻底失败，无论我们如何努力都无法完成。我们推出了一些新变更，导致系统不稳定；我们推送了一些修复程序，但这些程序又带来了新的 bug；我们推送了更多修复程序，但这只会导致更多的问题。团队通宵达旦地工作，直到第二天，我们仍然无法让系统稳定下来。最终，在经历了数天的部署噩梦后，我们不得不回滚所有部署。

Here was a company worth nearly $10 billion, and we could not deploy code. To get out of this mess, we kicked off Project Inversion, which was a complete freeze on all new feature development for several months while the engineering, product, and design teams reworked all the underlying infrastructure, tooling, and practices. The result was a huge success: months later, we were able to deploy dozens of times per day, with far fewer issues and outages, and that allowed the whole company to move faster.
当时，我们是一家市值近 100 亿美元的公司，却无法部署代码。为了摆脱困境，我们启动了“项目逆转”（Project Inversion），在几个月的时间里，我们完全冻结了所有新功能的开发，同时工程、产品和设计团队对所有底层基础设施、工具和流程进行了重构。结果非常成功：几个月后，我们每天可以部署数十次，问题和故障也大大减少，这使得整个公司的发展速度更快。

Today, we might call this a “DevOps transformation” (though back then, the term “DevOps” had just appeared on the scene, so we didn’t call it that), and to get there, we had to go through a lot of pain and outages. The truth is, we didn’t know what we didn’t know. We had to go out and chat with companies across the industry, learning about trunk-based development from one company, canary deployments from another, feature toggles from another, and so on.
如今，我们或许会称之为“DevOps转型”（尽管当时“DevOps”这个词才刚刚出现，所以我们并没有这样称呼它），而为了实现这一目标，我们经历了许多痛苦和故障。事实上，我们当时对很多事情都一无所知。我们不得不走出去，与业内各家公司交流，从一家公司学习主干开发，从另一家公司学习金丝雀部署，从另一家公司学习功能切换等等。

Sadly, even now, as I write this book nearly 15 years later, relatively few developers know about these DevOps and software delivery practices. After leaving LinkedIn, I cofounded Gruntwork, where I had the opportunity to work with hundreds of companies on their DevOps and software delivery practices. What I saw was LinkedIn’s DevOps nightmare repeated over and over again at companies of all sizes. The techniques that a handful of the top tech companies had figured out were not filtering down to the rest of the industry. Most developers out there still don’t know what they don’t know.
遗憾的是，即使在我撰写这本书的近15年后，仍然只有相对较少的开发人员了解这些DevOps和软件交付实践。离开LinkedIn后，我联合创立了Gruntwork，在那里我有机会与数百家公司合作，帮助他们改进DevOps和软件交付实践。我看到的是LinkedIn的DevOps噩梦在各种规模的公司中反复上演。少数顶尖科技公司掌握的技术并没有普及到整个行业。大多数开发者仍然不知道自己不知道什么。

So I decided to write a book. I hope that this book can be a small step in improving this situation. I hope that a comprehensive, hands-on overview of DevOps and software delivery will help the next generation of software companies get off on the right foot and avoid some of the DevOps nightmares I’ve seen. I hope that instead of just hacking things together and learning things the hard way, this book will allow you to learn from the experience of others.
所以我决定写一本书。我希望这本书能为改善这种状况贡献一份力量。我希望这本全面而实用的DevOps和软件交付概述能够帮助新一代软件公司迈出正确的第一步，避免我所见过的DevOps噩梦。我希望这本书能够让你从他人的经验中学习，而不是仅仅靠摸索和反复尝试来学习。

Perhaps the result will be a software industry that can build software faster, more reliably, and more securely. If that happens, it could have a profound impact on the industry, as described next.
或许最终的结果是，软件行业能够更快、更可靠、更安全地构建软件。如果真的如此，它将对整个行业产生深远的影响，如下所述。

The Impact of World-Class Software Delivery
世界级软件交付的影响

The vast majority of developers have never had the opportunity to see what world-class software delivery looks like firsthand. If you’re one of them, you’ll be astonished by the gap between companies with world-class software delivery processes and everyone else. It’s not a 1.1 times or 1.5 times improvement: it’s 10 times, 100 times, or more.
绝大多数开发人员从未有机会亲眼目睹世界级软件交付的运作模式。如果您也是其中之一，那么您一定会对拥有世界级软件交付流程的公司与其他公司之间的巨大差距感到震惊。这并非1.1倍或1.5倍的提升，而是10倍、100倍甚至更高。

Table P-1 shows the difference between elite performers and low performers in the four key DevOps Research and Assessment (DORA) metrics, which are a quick way to assess the performance of a software development team.
表P-1展示了优秀团队与表现欠佳团队在四项关键DevOps研究与评估（DORA）指标上的差异。这些指标能够快速评估软件开发团队的绩效。

Table P-1. DORA metrics performance from the 2024 State of DevOps Report
表P-1：2024年DevOps现状报告中的DORA指标表现

Metric | Description | Elite vs. low performers
Deployment frequency | How often you deploy to production | 182× more often
Lead time | How long it takes a change to go from committed to deployed | 127× faster
Change failure rate | How often deployments cause failures that need immediate remediation | 8× lower
Recovery time | How long it takes to recover from a failed deployment |2,293× faster
指标 | 描述 | 优秀与低绩效者对比
部署频率 | 部署到生产环境的频率 | 频率提升 182 倍
交付周期 | 从提交变更到部署完成所需的时间 | 速度提升 127 倍
变更失败率 | 部署导致需要立即修复的故障的频率 | 降低 8 倍
恢复时间 | 从部署失败中恢复所需的时间 | 速度提升 2,293 倍

To put these staggering differences into perspective, onsider these examples:
为了更直观地理解这些巨大的差异，请看以下例子：

● Deploying once per month versus many times per day
● Deployment processes that take 36 hours versus 5 minutes
● Two out of three deployments causing problems versus one out of twenty
● Outages that last 24 hours versus 2 minutes
● 每月部署一次 vs. 每天多次部署
● 部署过程耗时 36 小时 vs. 5 分钟
● 三次部署中有两次出现问题 vs. 二十次部署中只有一次出现问题
● 服务中断持续时间 24 小时 vs. 2 分钟

It’s almost a meme that developers who leave companies with world-class software delivery processes, such as Google, Meta, Amazon, or LinkedIn (after Project Inversion), complain bitterly about how much they miss the infrastructure and tooling. That’s because they are used to a world that looks like this:
离开拥有世界一流软件交付流程的公司（例如 Google、Meta、Amazon 或 LinkedIn（在 Project Inversion 之后））的开发者，常常抱怨自己多么怀念公司的基础设施和工具，这几乎成了一种梗。这是因为他们已经习惯了这样的世界：

● They can deploy anytime they want, even thousands of times per day.
● Deployments can happen in minutes, and they are 100% automated.
● Problems can be detected in seconds, often before any user-visible impact.
● Outages can be resolved in minutes, often automatically.

● 他们可以随时部署，甚至一天部署数千次。
● 部署只需几分钟，而且完全自动化。
● 问题可以在几秒钟内被检测到，通常在用户察觉到任何影响之前就能发现。
● 服务中断可以在几分钟内解决，而且通常是自动解决。

What do the equivalent numbers look like at your organization? If you’re not even in the ballpark, don’t fret.The first thing you need to know is that it’s possible to achieve these results, even if you’re not a multibillion-dollar company. In fact, there are many ways to achieve these sorts of results, and each of those world-class companies does it a bit differently. That said, they also have a lot in common, and DevOps is an attempt to capture some of the common patterns.
贵公司相应的数字是多少？如果还差得很远，也别担心。首先，你需要知道的是，即使你不是一家数十亿美元的公司，也完全有可能取得这些成果。事实上，实现这类成果的方法有很多，而每一家世界级公司都有其独特的做法。尽管如此，它们之间也有很多共同之处，DevOps 正是试图捕捉其中的一些共同模式。

Where DevOps Came From
DevOps 的起源
DevOps emerged in the late 2000s as a response to inefficiencies in the way companies delivered software. Historically, most companies had a Developer (Dev) team responsible for writing the software, and an Operations (Ops) team responsible for managing the hardware. In many companies, these teams worked in silos with conflicting objectives. The Ops team’s core objectives were usually security and reliability, so they were the only ones with access to production systems, and were on the hook for doing deployments and dealing with outages. The Dev team’s core objectives were usually to ship features and to do so as quickly as possible. This arrangement often led to problems.
DevOps 兴起于 2000 年代后期，旨在解决公司软件交付方式效率低下的问题。过去，大多数公司都设有负责编写软件的开发 (Dev) 团队和负责管理硬件的运维 (Ops) 团队。在许多公司，这两个团队各自为政，目标相互冲突。运维团队的核心目标通常是安全性和可靠性，因此他们是唯一有权访问生产系统的团队，并负责部署和处理故障。而开发团队的核心目标通常是尽快交付功能。这种模式常常导致问题。

The Dev team, which was typically working under time pressure, with no access to production systems or on-call duties, would write the code, and with little testing, “toss it over the wall” to the Ops team. The Ops team would then manually deploy that code, which frequently led to failures or outages, either from an error in the deployment process or a bug in the code. The Ops team, tired of waking up at 3 a.m. to deal with outages, would end up reducing the release cadence. Unfortunately, this led to a vicious cycle: fewer releases meant each release was bigger and more complicated, which led to more outages, which led to an even slower release cadence, and so on, until the company would grind to a halt.
开发团队通常面临时间压力，既没有生产系统的访问权限，也没有值班职责，他们编写代码后，几乎不做任何测试就“扔”给运维团队。运维团队随后手动部署这些代码，这经常导致故障或中断，原因可能是部署过程中的错误，也可能是代码本身的缺陷。运维团队厌倦了凌晨三点起床处理故障，最终不得不降低发布频率。不幸的是，这导致了一个恶性循环：发布频率降低意味着每次发布都规模更大、更复杂，从而导致更多故障，进而导致发布频率进一步降低，如此循环往复，直至公司陷入瘫痪。

Although the problems with manual processes and siloing were known for many years, it wasn’t until around 2007– 2008 that the software industry started to discuss these issues more openly in various conferences, meetups, and articles. These discussions coincided with, and were big drivers of, several major shifts that happened over the next decade:
尽管人工流程和信息孤岛的问题由来已久，但直到 2007-2008 年左右，软件行业才开始在各种会议、聚会和文章中更公开地讨论这些问题。这些讨论恰逢并推动了接下来十年发生的几项重大变革：

The shift to the cloud
Instead of managing their own data centers, many companies started moving to the cloud, renting servers and other infrastructure from third-party providers (you’ll learn all about the cloud in Chapter 1). This represented a big shift for both the Ops team, which was suddenly spending most of its time dealing with software (from the cloud provider) instead of hardware (e.g., racking servers and plugging in network cables), and the Dev team, which could now access production systems through the same software tools that Ops was using.
向云端迁移
许多公司不再自行管理数据中心，而是开始迁移到云端，从第三方供应商租用服务器和其他基础设施（您将在第一章中了解云的全部内容）。这对于运维团队和开发团队来说都是一次重大转变。运维团队突然将大部分时间用于处理软件（来自云供应商），而不是硬件（例如，服务器机架安装和网线连接）；而开发团队现在也可以通过运维团队使用的相同软件工具访问生产系统。

The shift to automation
Instead of doing everything manually, many companies started to automate their processes via configuration management tools (Chapter 2), orchestration tools (Chapter 3), automated testing (Chapter 4), and continuous integration/continuous delivery (Chapter 5). These automations were another big shift for both Dev and Ops, as they defined a new set of interaction points between the two teams (a bit like an API).
向自动化迁移
许多公司不再手动操作，而是开始通过配置管理工具（第二章）、编排工具（第三章）、自动化测试（第四章）和持续集成/持续交付（第五章）来实现流程自动化。这些自动化对于开发和运维团队来说又是一次重大转变，因为它们定义了两个团队之间新的交互点（有点像 API）。

The shift to cross-functional teams
Instead of working in silos, many companies started to have Dev and Ops work more closely together on cross-functional teams with shared objectives and shared tooling (such as the cloud and automation tooling).
向跨职能团队的转变
许多公司不再各自为政，而是让开发和运维人员在跨职能团队中更紧密地合作，拥有共同的目标和共享的工具（例如云和自动化工具）。

All these trends together became known as the DevOps movement. DevOps isn’t the name of a team or a job title or a particular technology (though you’ll see it used for all three). Instead, it’s a set of processes, ideas, and techniques. Everyone has a slightly different definition of DevOps, but for this book, I’m going to define DevOps as a methodology with the following goal:
The goal of DevOps is to make software delivery vastly more efficient.
所有这些趋势共同构成了DevOps运动。DevOps并非指某个团队、职位或特定技术（尽管你会看到它被用来指代这三者）。相反，它是一套流程、理念和技术。每个人对DevOps的定义略有不同，但在本书中，我将DevOps定义为一种方法论，其目标如下：
DevOps的目标是大幅提升软件交付效率。

You read how LinkedIn’s DevOps transformation saved the company, but there are many other examples. Nordstrom found that applying DevOps practices increased the number of features it delivered per month by 100%, reduced defects by 50%, reduced lead times by 60%, and reduced the number of production incidents by 60% to 90%. After HP’s LaserJet Firmware division began using DevOps practices, the amount of time its developers spent on developing new features increased from 5% to 40%, and overall development costs were reduced by 40%. Etsy used DevOps practices to go from stressful, infrequent deployments that caused numerous outages to deploying 25 to 50 times per day, with fewer outages.1
你可能读过LinkedIn如何通过DevOps转型拯救公司，但还有许多其他例子。Nordstrom发现，应用DevOps实践后，其每月交付的功能数量增加了100%，缺陷减少了50%，交付周期缩短了60%，生产事故数量减少了60%到90%。惠普的LaserJet固件部门开始采用DevOps实践后，其开发人员用于开发新功能的时间从5%增加到40%，整体开发成本降低了40%。 Etsy运用DevOps实践，将原本压力巨大、部署频率低且导致频繁宕机的部署模式，转变为每天部署25到50次，并且宕机次数显著减少。¹

All that said, a fair warning: while the results from adopting DevOps can be wonderful, the experience along the way can be anything but wonderful, as described next.
尽管如此，仍需谨慎提醒：采用DevOps带来的成果固然可喜，但其过程中的体验却可能并不美好，如下所述。

Watch Out for Snakes
小心蛇出没

I’m going to let you in on a little secret: we use a single word, “DevOps,” to describe what’s actually dozens and dozens of largely unrelated concepts. What does the cryptography behind a TLS certificate have to do with defining a deployment pipeline in GitHub Actions YAML or backing up data from a PostgreSQL database? Not much.And yet, your typical site reliability engineer (SRE) or DevOps engineer has to deal with all of these, and countless other concepts too.
我要告诉你一个小秘密：我们用“DevOps”这个词来描述实际上几十个互不相关的概念。TLS证书背后的加密技术与在GitHub Actions YAML中定义部署管道或从PostgreSQL数据库备份数据有什么关系？关系不大。然而，典型的站点可靠性工程师（SRE）或DevOps工程师却必须处理所有这些概念，以及无数其他概念。

What makes DevOps hard is not that any one of these concepts is incredibly complicated by itself, but that there are so many concepts to master—and you have to connect them all together just right. The TLS certificate must be configured just right, or your users will get scary errors that prevent them from accessing your website. Your deployment pipeline must be configured just right, or your team won’t be able to deploy. Your database backup must be set up just right, or you are at risk of data loss, and if you lose all your data, you may go out of business entirely.DevOps is a remarkable combination of an incredibly broad surface area, but also one requiring you to sweat every single detail—for either you get everything connected together correctly, or nothing works at all.
DevOps的难点不在于这些概念本身有多么复杂，而在于需要掌握的概念太多——而且你必须将它们完美地结合起来。TLS证书必须配置正确，否则用户会遇到可怕的错误，导致他们无法访问你的网站。你的部署管道必须配置正确，否则你的团队将无法进行部署。数据库备份必须设置得当，否则就有数据丢失的风险；如果所有数据都丢失了，公司可能就此倒闭。DevOps 涵盖的范围极其广泛，但同时也要求你关注每一个细节——要么所有环节都连接正确，要么一切都无法正常运转。

I often use the analogy of a box of cables: you reach into the box, hoping to pull out just one cable, but you inevitably end up pulling out a giant, tangled mess. Unfortunately, that’s the state of DevOps today. It’s a relatively new industry, the tools and techniques we have aren’t that mature, and it often feels like everything is broken and frustrating and hopelessly tangled.
我经常用一盒线缆来打比方：你伸手进去，本想只抽出一根线缆，结果却总是抽出一大堆乱七八糟的线缆。不幸的是，这就是如今 DevOps 的现状。这是一个相对较新的行业，我们现有的工具和技术还不够成熟，常常让人感觉一切都乱成一团，令人沮丧，而且无解。

My hope in this book is, as much as I can, to untangle this mess of cables for you. To show you that these are, in fact, separate cables—separate concepts—that, in isolation, are something you can readily understand, begin to work with, and ultimately become proficient in.
我希望通过这本书，尽我所能地帮你理清这团乱麻。为了向你展示，这些实际上是不同的线缆——不同的概念——单独来看，你可以轻松理解、上手使用，并最终精通它们。

But sometimes this is hard to do. Sometimes, reaching into this box of cables feels more like reaching into a box of snakes. You end up getting bitten. If you find yourself sitting there, staring at a nonsense error message, tearing your hair out, stressed, angry, and afraid, know this: you are not alone.
但有时这很难做到。有时，打开这堆线缆就像打开一盒毒蛇。你最终会被咬伤。如果你发现自己坐在那里，盯着一条莫名其妙的错误信息，抓耳挠腮，压力山大，怒火中烧，恐惧万分，请记住：你并不孤单。

Thousands of other developers are reaching into that box of snakes and getting bitten, every day. I’m one of them. I’ve lost more hair to DevOps than I care to admit. Even while writing this book, I frequently found myself frustrated or confused or yelling at my screen, even though I’ve done most of these things a thousand times. That’s just how it is today.
每天都有成千上万的开发者像我一样，打开这盒毒蛇，然后被咬伤。我也是其中之一。我因为 DevOps 而掉的头发比我愿意承认的还要多。即使在写这本书的时候，我也经常感到沮丧、困惑，或者对着屏幕大喊大叫，尽管这些事情我已经做过无数次了。这就是现在的现状。

In fact, in a few places in this book, I haven’t been able to untangle the wires as much as I’d like. For instance, some example code was just too complicated and long to include in the book, so I have to settle for a simpler and less realistic version. Or I can’t explain a certain concept without introducing 10 other concepts that come later, so I can give you only a partial explanation for now. In cases like these, I’ve added a “box of snakes” warning that looks like this:
事实上，本书中有些地方，我没能像我希望的那样把所有逻辑都理清楚。例如，有些示例代码过于复杂冗长，无法全部收录到书中，所以我只能提供一个更简单但不太贴近实际的版本。又或者，我无法在不引入后面会提到的其他十个概念的情况下解释某个概念，所以现在我只能给出部分解释。对于这种情况，我添加了一个类似这样的“蛇形框”警告：

WATCH OUT FOR SNAKES
When you see one of these warnings, be prepared to enter a particularly hairy and tangled corner of DevOps.
小心蛇出没
当你看到这类警告时，就要做好准备，进入DevOps领域一个格外棘手且错综复杂的角落。

Whenever you see such a warning, understand that you’re going to see part of the picture now but perhaps won’t be able to get the full picture until later. This is true of DevOps in general. If you’re new to DevOps, the content will initially seem strange, confusing, and full of incomprehensible buzzwords. And each time you go to learn a new buzzword, you’re hit with 10 more unfamiliar buzzwords, so you never feel like you’re getting the whole picture. But I promise that if you give it enough time, you’ll eventually get over a hump, and suddenly, the pieces will start to make sense and really come together. You need to build up a big enough base of knowledge and experience, and it’s hard going at first, but at some point, it starts to get easier. DevOps never becomes completely easy, but you get to a point where you always feel confident that you can figure it out.
每当你看到这样的警告时，要明白你现在看到的只是冰山一角，可能要过一段时间才能看到全貌。这在 DevOps 领域尤为如此。如果你是 DevOps 新手，一开始你会觉得内容陌生、混乱，充斥着晦涩难懂的专业术语。而且，每次你学习一个新的专业术语，就会有十个新的陌生术语接踵而至，让你始终感觉自己无法掌握全貌。但我保证，只要你坚持足够长的时间，最终就能克服难关，突然间，所有知识点都会豁然开朗，融会贯通。你需要积累足够的知识和经验，一开始会很艰难，但总有一天会变得轻松一些。DevOps 永远不会变得完全简单，但你会逐渐建立起一种自信，相信自己能够解决所有问题。

So stick with it. And watch out for those snakes.
所以，坚持下去。同时也要小心那些“蛇”（可能指潜在的陷阱）。

Who Should Read This Book
谁应该读这本书？

This book is for anyone responsible for deploying and managing apps in production—that is, anyone responsible for software delivery. This includes the following: 
本书面向所有负责在生产环境中部署和管理应用程序的人员，也就是所有负责软件交付的人员。这包括以下几类人员：

● Individual contributors in operations roles 
Current and aspiring SREs, DevOps engineers, sysadmins, operations engineers, and release engineers who want to level up their knowledge of software delivery.
● 运维岗位的个人贡献者：现任和未来的SRE、DevOps工程师、系统管理员、运维工程师和发布工程师，他们希望提升软件交付方面的知识。
● Individual contributors in dev roles 
Software engineers, software developers, web developers, and full stack engineers who want to learn more about the operations side of the house.
● 开发岗位的个人贡献者：软件工程师、软件开发人员、Web开发人员和全栈工程师，他们希望了解更多运维方面的知识。
● Managers 
Engineering managers, engineering directors, chief technology officers (CTOs), vice presidents of engineering
● 管理人员：工程经理、工程总监、首席技术官 (CTO)、工程副总裁。

This book does not assume that you’re already an expert coder or expert sysadmin. A basic familiarity with programming, the command line, and server-based software (e.g., websites) should suffice. Everything else you need, you’ll be able to pick up as you go. The only tools you need are a computer, an internet connection, and the desire to learn.
本书并不假定您已经是编程专家或系统管理员。您只需具备编程、命令行和服务器端软件（例如网站）的基本知识即可。其他所需的技能，您都可以边学边做。您只需要一台电脑、一个网络连接和一颗学习的心。

What You’ll Find in This Book
Table P-2 shows a chapter-by-chapter outline of the book’s content, including the key ideas you’ll explore and the hands-on examples you’ll try in each chapter.
本书内容简介
表 P-2 列出了本书各章节的内容概要，包括您将在每一章中探讨的关键概念和您将尝试的实践示例。

略

Feel free to read the book from beginning to end or jump around to the chapters that interest you the most. Note that the examples in each chapter reference and build upon the examples from the previous chapters, so if you skip around, use the open source code examples (as described in “Open Source Code Examples”) to catch up.
您可以随意从头到尾阅读本书，也可以跳到您最感兴趣的章节。请注意，每章的示例都会引用并建立在前一章的示例之上，因此如果您跳读，请使用开源代码示例（如“开源代码示例”部分所述）来跟上进度。

On the book’s website, you’ll find a dedicated page for each chapter (for example, here is the dedicated page for Chapter 1), which includes a list of recommended resources (books, blog posts, courses) you can use to go deeper on the topics covered in that chapter, as well as a list of all the tools mentioned in that chapter.
在本书的网站上，您会找到每个章节的专属页面（例如，这是第一章的专属页面），其中包含推荐资源列表（书籍、博客文章、课程），您可以利用这些资源深入了解该章节涵盖的主题，以及该章节中提到的所有工具列表。

Given the breadth of DevOps, this book covers a lot of ground and includes a lot of detail. To help you avoid missing the forest for the trees, I call out the key takeaways in each chapter as follows:
鉴于 DevOps 的广泛性，本书涵盖的内容非常丰富，细节也十分详尽。为了帮助您把握全局，我总结了每章的关键要点如下：
KEY TAKEAWAY 1
A key takeaway from the chapter.
要点总结 1
本章的一个关键要点。

Pay special attention to these items, as they typically highlight the most important lessons in that chapter.
请特别注意这些内容，因为它们通常突出了该章节中最重要的一些要点。

What You Won’t Find in This Book
本书不包含的内容
This book is meant to fill a specific gap: a hands-on guide to DevOps and software delivery, targeted at practitioners.This is already a huge amount of content to cover, which means that this book will either skip or only touch on lightly the following DevOps and software delivery topics:
本书旨在填补一个特定的空白：一本面向实践者的DevOps和软件交付实战指南。由于涵盖的内容已经非常庞大，因此本书将略过或仅简要提及以下DevOps和软件交付主题：

DevOps culture and organizational processes
Most DevOps books primarily focus on DevOps culture and organizational processes such as cross-functional teams, capacity planning, blameless postmortems, on-call rotations, key performance indicators (KPIs), service-level objectives (SLOs), and error budgets, so this book won’t spend much time on these items.
DevOps 文化和组织流程
大多数 DevOps 书籍主要关注 DevOps 文化和组织流程，例如跨职能团队、容量规划、无责事后分析、轮值待命、关键绩效指标 (KPI)、服务级别目标 (SLO) 和错误预算，因此本书不会在这些方面花费太多篇幅。

Server hardening
While this book covers a range of security topics, I can’t cover them all. In particular, I don’t focus on how to harden your servers against attacks—for example, operating system (OS) permissions, intrusion protection, file integrity monitoring, sandboxing, and hardened images.
服务器加固
本书涵盖了一系列安全主题，但无法面面俱到。特别是，本书不会着重讲解如何加固服务器以抵御攻击——例如操作系统 (OS) 权限、入侵防护、文件完整性监控、沙箱和加固镜像。

Low-level networking
This book includes a chapter on networking, but it focuses on only higher-level concepts: DNS, CDNs, VPCs, VPNs, service meshes, and basic network hardening. This chapter does not go into any lower-level details, such as routers, switches, links, or routing protocols.
底层网络
本书包含一个关于网络的章节，但仅关注高层概念：DNS、CDN、VPC、VPN、服务网格和基本网络加固。本章不会深入探讨任何底层细节，例如路由器、交换机、链路或路由协议。

Compliance
DevOps engineers are often tasked with helping their companies meet various compliance standards and regulations, such as Systems and Organization Controls 2 (SOC 2), International Organization for Standardization (ISO) standard 27001, Health Insurance Portability and Accountability Act (HIPAA), Payment Card Industry Data Security Standard (PCI DSS), and the National Institute of Standards and Technology (NIST) 800-171 requirements. While the practices I recommend go a long way toward setting up the kind of security posture you need to meet these compliance standards, this book is not a detailed guide on meeting any standard in particular.
合规性
DevOps 工程师经常需要帮助公司满足各种合规标准和法规，例如系统与组织控制 2 (SOC 2)、国际标准化组织 (ISO) 27001 标准、健康保险流通与责任法案 (HIPAA)、支付卡行业数据安全标准 (PCI DSS) 以及美国国家标准与技术研究院 (NIST) 800-171 要求。虽然我推荐的实践方法对于构建满足这些合规标准所需的安全态势大有裨益，但本书并非针对任何特定标准的详细指南。

Cost optimization and performance tuning
DevOps engineers are also often asked to help optimize the company’s systems to reduce costs or improve performance.These are detailed and ever-changing topics in their own right, so this book touches on them at only a surface level.
成本优化和性能调优
DevOps 工程师也经常被要求帮助优化公司系统以降低成本或提升性能。这些本身就是复杂且不断变化的主题，因此本书仅作浅尝辄止的介绍。

Open Source Code Examples
开源代码示例

This book includes many examples for you to work through.
You can find all these code samples in the following GitHub repository: https://github.com/brikis98/devops-book.
You might want to check out this repo before you begin reading so you can follow along with all the examples on your own computer:
$ git clone https://github.com/brikis98/devops-book.git
本书包含大量示例供您练习。
您可以在以下 GitHub 仓库中找到所有这些代码示例：https://github.com/brikis98/devops-book。
建议您在开始阅读之前先克隆此仓库，以便在自己的计算机上跟随所有示例进行练习：
$ git clone https://github.com/brikis98/devops-book.git

The code samples are organized by chapter (e.g., ch1, ch2), and, within each chapter, by tool (e.g., ansible, kubernetes, tofu). For example, the example Packer template in Chapter 2 is in the folder ch2/packer, and the example OpenTofu module called lambda in Chapter 3 is in the folder ch3/tofu/modules/lambda.
代码示例按章节（例如，ch1、ch2）组织，每个章节内又按工具（例如，ansible、kubernetes、tofu）组织。例如，第 2 章中的 Packer 模板示例位于 ch2/packer 文件夹中，第 3 章中的 OpenTofu 模块 lambda 示例位于 ch3/tofu/modules/lambda 文件夹中。

EMBEDDED SANDBOX ON THE O’REILLY
LEARNING PLATFORM
O’Reilly 在线学习平台上的嵌入式沙箱

The version of this book on the O’Reilly online learning platform includes an embedded sandbox preconfigured with all the code examples, access credentials for an Amazon Web Services (AWS) account, a code editor, and a terminal, so you can try out all the examples in your browser without having to install anything.
本书在 O’Reilly 在线学习平台上的版本包含一个预配置了所有代码示例的嵌入式沙箱，其中包含 Amazon Web Services (AWS) 账户的访问凭证、代码编辑器和终端，因此您无需安装任何软件即可在浏览器中尝试所有示例。

It’s worth noting that most of the examples show you what the code looks like at the end of a chapter. If you want to maximize your learning, you’re better off writing the code yourself, from scratch, and checking the “official” solutions only at the end.
值得注意的是，大多数示例会在章节末尾显示代码的最终效果。如果您想最大程度地提高学习效率，最好从头开始自己编写代码，最后再参考“官方”解决方案。

AN IMPORTANT NOTE FOR WINDOWS USERS
Windows 用户须知

While the example code included in this book should work on any OS, the book also includes many example terminal commands that you run locally. These terminal commands are mostly written in Bash, so to run them, you need either a computer with Unix, Linux, or macOS, or, if you’re on Microsoft Windows, you can use Windows Subsystem for Linux or Cygwin.
虽然本书中包含的示例代码应该可以在任何操作系统上运行，但本书也包含许多需要在本地运行的终端命令示例。这些终端命令大多使用 Bash 编写，因此您需要一台运行 Unix、Linux 或 macOS 的计算机才能运行它们；如果您使用的是 Microsoft Windows 系统，则可以使用 Windows 子系统 for Linux 或 Cygwin。

Opinionated Code Examples
带有倾向性的代码示例

The core concepts in the book (e.g., managing infrastructure as code, CI/CD, networking, and secrets management) are relatively ubiquitous and applicable across the entire software industry. The code samples, however, represent just one opinionated way to implement these core concepts. The examples are there to give you hands-on practice and to help with learning. They are not the only way or the best way to do things.
本书的核心概念（例如，基础设施即代码、持续集成/持续交付 (CI/CD)、网络和密钥管理）在整个软件行业中都相对普遍适用。然而，代码示例仅代表实现这些核心概念的一种倾向性方法。这些示例旨在提供实践机会并帮助您学习。它们并非唯一的方法，也不是最佳方法。

In the real world, there is no single “best” way that applies to all circumstances. All technology choices are trade-offs, and some solutions will be a better fit in some situations than others. The goal of this book is to teach you the underlying concepts and techniques of DevOps and software delivery, and not a specific set of tools or technologies. After you understand the basics, feel free to explore other technologies and approaches, and always use your judgment to pick the right tool for the job.
在现实世界中，并不存在适用于所有情况的“最佳”方法。所有技术选择都是一种权衡，某些解决方案在某些情况下会比其他方案更合适。本书的目标是教授您 DevOps 和软件交付的基本概念和技术，而不是特定的工具或技术。在您理解基础知识之后，您可以自由探索其他技术和方法，并始终运用您的判断力来选择合适的工具。

A NOTE ABOUT VERSIONS
Whereas the core concepts in this book change only over relatively long time spans, the code samples used to demonstrate and implement the core concepts change more frequently. Therefore, by the time you read this, some of the examples could be out of date. I’ll try to update the examples as often as I can, but if you hit an issue, please file a bug in the book’s GitHub repo.
关于版本说明
本书的核心概念变化相对较慢，但用于演示和实现这些核心概念的代码示例更新频率更高。因此，当您阅读本书时，部分示例可能已经过时。我会尽可能频繁地更新示例，但如果您遇到任何问题，请在本书的 GitHub 代码库中提交 bug 报告。

You Have to Get Your Hands Dirty
你必须亲身实践

A book on weight lifting can teach you principles, routines, and exercises, but you have to spend hours in the gym practicing, sweating, and applying what you learned to be able to lift serious weight. Likewise, a book on DevOps and software delivery can teach you principles, techniques, and tools, but you have to spend hours writing code, debugging systems, and applying what you learned to be able to achieve serious results.
一本关于举重的书可以教你原理、训练计划和练习方法，但你必须在健身房里花费数小时练习、挥汗如雨，并将所学知识付诸实践，才能真正举起重物。同样，一本关于 DevOps 和软件交付的书可以教你原理、技术和工具，但你必须花费数小时编写代码、调试系统，并将所学知识付诸实践，才能取得显著成果。

That’s what the code examples in this book are for. Instead of only reading, you get to learn by doing. So don’t just skim the code examples: write the code, run it, and get it working. Moreover, you’ll see sections like the following throughout the book:
本书中的代码示例正是为此而设。你不再只是阅读，而是通过实践来学习。所以不要只是浏览代码示例：编写代码，运行它，让它运转起来。此外，你会在本书中看到类似以下的章节：

The examples in this book will get you to the point where you have something working; these “Get Your Hands Dirty” sections are an opportunity for you to take those examples and tweak them, customize them to your needs, break things, figure out how to fix them, and so on. Think of this as time spent practicing and sweating at the gym. Getting your hands dirty is when the real learning happens.
本书中的示例将帮助你实现一些功能；这些“亲身实践”章节为你提供了一个机会，让你可以对这些示例进行调整、根据自身需求进行定制、找出问题所在，并找出解决方法等等。把这想象成在健身房里挥汗如雨的练习时间。亲身实践才能真正学到东西。

Using Code Examples
使用代码示例

We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at https://oreil.ly/DevOps-and-software-delivery.
本书设有网页，其中列出了勘误、示例和任何其他信息。您可以通过 https://oreil.ly/DevOps-and-software-delivery 访问此页面。

This book is here to help you get your job done. In general, if example code is offered with this book, you may use it in your programs and documentation. You do not need to contact us for permission unless you’re reproducing a significant portion of the code. For example, writing a program that uses several chunks of code from this book does not require permission. Selling or distributing examples from O’Reilly books does require permission.
本书旨在帮助您完成工作。通常情况下，如果本书提供了示例代码，您可以在自己的程序和文档中使用这些代码。除非您复制了大量代码，否则无需联系我们获得许可。例如，编写一个使用本书中几段代码的程序无需获得许可。但出售或分发 O’Reilly 出版的书籍中的示例需要获得许可。

Answering a question by citing this book and quoting example code does not require permission. Incorporating a significant amount of example code from this book into your product’s documentation does require permission.
通过引用本书和示例代码来回答问题无需获得许可。但将本书中的大量示例代码整合到您的产品文档中需要获得许可。

We appreciate, but generally do not require, attribution. An attribution usually includes the title, author, publisher, and ISBN. For example: “Fundamentals of DevOps and Software Delivery by Yevgeniy Brikman (O’Reilly).
我们感谢您注明出处，但通常不强制要求。注明出处通常包括书名、作者、出版社和 ISBN。例如：“《DevOps 和软件交付基础》，作者：Yevgeniy Brikman（O’Reilly 出版社）。

Copyright 2025 Yevgeniy “Jim” Brikman, 978-1-098-17459- 0.” If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at permissions@oreilly.com.
版权所有 © 2025 Yevgeniy “Jim” Brikman，978-1-098-17459-0。” 如果您认为您对代码示例的使用超出合理使用范围或未获得上述许可，请随时通过 permissions@oreilly.com 与我们联系。


# Chapter 1. How to Deploy Your App
In the Preface, you read that DevOps consists of dozens of concepts. But it almost always starts with just one question: “I wrote an app. Now what?” You and your team have spent months putting together an app. You picked a programming language, implemented the backend, designed and built a user interface (UI), and finally, it’s time to expose the app to real users. How, exactly, do you do that?
在前言中，您读到 DevOps 包含数十个概念。但它几乎总是始于一个问题：“我写了一个应用，接下来该做什么？” 您和您的团队花了几个月的时间开发这个应用。你们选择了编程语言，实现了后端，设计并构建了用户界面 (UI)，现在终于到了将应用发布给真实用户的时候了。那么，究竟该如何操作呢？

There are so many questions to figure out here. Should you use AWS or Azure? (And what about Heroku or Vercel?) Do you need one server or multiple servers? (Or serverless?) Do you need to use Docker? (Or Kubernetes?) Do you need a VPC? (Or a VPN?) How do you get a domain name? (And what about a TLS certificate?) What’s the right way to set up your database? (And how do you back it up?) Why did that app crash? Why does nothing seem to be working?
这里有太多问题需要解决。您应该使用 AWS 还是 Azure？（Heroku 或 Vercel 呢？）您需要一台服务器还是多台服务器？（或者无服务器架构？）您需要使用 Docker 吗？（或者 Kubernetes？）您需要 VPC 吗？（或者 VPN？）如何获取域名？（TLS 证书呢？）如何正确设置数据库？（如何备份？）为什么应用崩溃了？为什么一切似乎都无法正常运行？

Why is this so hard?
为什么这么难？

OK, easy now. Take a deep breath. If you’re new to software delivery—you’ve worked as an app developer your whole career, or you’re just starting out in operations—it can be overwhelming, and you can get stuck in analysis paralysis. This book is here to help. I will walk you through each of these questions—and many others you didn’t think to ask—and help you figure out the answers, step-by-step.
好了，别着急。深呼吸。如果你是软件交付新手——无论你职业生涯一直从事应用开发，还是刚刚踏入运维领域——都可能感到不知所措，甚至陷入分析瘫痪。本书旨在助你一臂之力。我将引导你逐一解答这些问题，以及许多你可能没有想到的问题，并一步步帮你找到答案。

The first step will be to deploy the app on a server and get it running in the most basic way you can. In this chapter, you’ll work through examples to deploy the same app on your own computer, on Render (a platform as a service), and on AWS (an infrastructure as a service). After that, you’ll see how to evolve your basic deployment as your company grows.
第一步是将应用部署到服务器上，并以最基本的方式运行。在本章中，你将通过示例学习如何将同一个应用部署到你自己的电脑、Render（平台即服务）和 AWS（基础设施即服务）上。之后，你将了解如何随着公司的发展而扩展你的基本部署方案。

Without further ado, let’s jump right in and start deploying some apps!
事不宜迟，让我们马上开始部署应用吧！

Example: Deploy the Sample App Locally
示例：在本地部署示例应用程序

The first place you should be able to deploy any app is locally, on your own computer. This is typically how you’d build the app in the first place, writing and running your code locally until it’s working. The way you deploy an app locally depends on the technology. Throughout this book, you’re going to be using a simple Node.js sample app.
任何应用程序的首选部署位置都应该是本地，也就是您自己的计算机上。通常情况下，您最初构建应用程序的方式就是在本地编写和运行代码，直到它能够正常工作。本地部署应用程序的方式取决于所使用的技术。本书中，您将使用一个简单的 Node.js 示例应用程序。

Create a new folder on your computer, perhaps called something like fundamentals-of-devops, which you can use to store code for the examples you’ll be running throughout the book. You can run the following commands in a terminal to create the folder and go into it:
在您的计算机上创建一个新文件夹，例如命名为 fundamentals-of-devops，用于存储本书中示例的代码。您可以在终端中运行以下命令来创建并进入该文件夹：

$ mkdir fundamentals-of-devops
$ cd fundamentals-of-devops

In that folder, create new subfolders for this chapter and the sample app:
在该文件夹中，为本章和示例应用程序创建新的子文件夹：
$ mkdir -p ch1/sample-app
$ cd ch1/sample-app

The sample app you’ll be using is a minimal “Hello, World” Node.js app, written in JavaScript. You don’t need to understand much JavaScript to make sense of the app. One of the nice things about getting started with Node.js is that all the code for a simple web app fits in a single file that’s about 10 lines long. Within the sample-app folder, create a file called app.js, with the contents shown in Example 1-1.
您将使用的示例应用程序是一个用 JavaScript 编写的极简“Hello, World”Node.js 应用程序。您无需精通 JavaScript 即可理解此应用程序。Node.js 的一大优势在于，一个简单的 Web 应用程序的所有代码都可以放在一个大约 10 行长的文件中。在 sample-app 文件夹中，创建一个名为 app.js 的文件，内容如示例 1-1 所示。

This “Hello, World” app does the following: 
1 Respond to all requests with a 200 status code and the text Hello, World!
2 Listen for requests on the port number specified via the PORT environment variable, or if PORT is not set, default to port 8080.
这个“Hello, World”应用程序执行以下操作：
1 对所有请求返回 200 状态码和文本“Hello, World!”
2 监听通过 PORT 环境变量指定的端口号上的请求；如果未设置 PORT，则默认使用端口 8080。

To run the app, you must first install Node.js (minimum version 21). You can then start the app with node app.js:
要运行此应用程序，您必须先安装 Node.js（最低版本 21）。然后，您可以使用 `node app.js` 命令启动应用程序：	
$ node app.js
Listening on port 8080

Congrats, you’re running the app locally! That’s a great start, but if you want to expose your app to users, you’ll need to run it on a server, as discussed next.
恭喜，您已在本地运行该应用程序！这是一个很好的开始，但如果您想将应用程序提供给用户，则需要将其运行在服务器上，如下所述。

Deploying an App on a Server
在服务器上部署应用程序

When you run an app on your computer, it is available only on localhost, a hostname configured to point to the loopback network interface, which means it bypasses any real network interface, and can be accessed only from your own computer and not from the outside world. This is by design and, for the most part, a good thing, as the way you run apps on a personal computer for development and testing is not the way you should run them when you want to expose them to outsiders.
当您在计算机上运行应用程序时，它只能通过 localhost 访问。localhost 是一个主机名，配置为指向回环网络接口。这意味着它绕过了任何实际的网络接口，只能从您自己的计算机访问，而无法从外部访问。这是有意为之的设计，而且在大多数情况下，这是一件好事。因为在个人计算机上进行开发和测试时运行应用程序的方式，并不适用于将应用程序暴露给外部用户的情况。

KEY TAKEAWAY 1
要点一
You should never expose apps running on a personal computer to the outside world.
您绝不应该将运行在个人电脑上的应用程序暴露给外部网络。

Instead, if you’re going to expose your app to the outside world, you should run it on a server. A server is a computer specifically designed for running apps and exposing those apps to the outside world. A server and a personal computer differ in many ways, including the following:
相反，如果您确实需要将应用程序暴露给外部网络，则应该将其运行在服务器上。服务器是专门为运行应用程序并将其暴露给外部网络而设计的计算机。服务器和个人电脑在许多方面都存在差异，包括以下几点：

Security
Most servers run a stripped-down OS and are hardened against attacks (e.g., firewall, intrusion-prevention tools, fileintegrity monitoring). Your personal computer has all sorts of extra software (any of which could have a vulnerability) and is not hardened.
安全性
大多数服务器运行的是精简版操作系统，并配备了安全加固措施以抵御攻击（例如防火墙、入侵防御工具、文件完整性监控）。您的个人电脑则安装了各种额外的软件（其中任何一个都可能存在漏洞），且没有进行安全加固。

Availability
Most servers are designed to be on all the time and have redundant power. Your personal computer may shut off at any time.
可用性
大多数服务器都设计为全天候运行，并配备冗余电源。您的个人电脑则可能随时关机。

Performance
Most servers run just the apps on them. You use your personal computer for other tasks (e.g., coding, browsing) that may impact your app’s performance.
性能
大多数服务器仅运行其上的应用程序。而您使用个人电脑执行其他任务（例如编码、浏览网页），这些任务可能会影响应用程序的性能。

Collaboration
Most apps are worked on by teams, and whereas other developers don’t (and shouldn’t) have access to your personal computer, servers are usually designed for team access.
协作
大多数应用程序都是由团队开发的，其他开发人员无法（也不应该）访问您的个人电脑，但服务器通常设计为团队访问。

For these reasons, always use a server to run your production apps. Broadly speaking, you have two ways to get access to servers (two options for hosting your apps):
● You can buy and set up your own servers (on premises).
● You can rent servers from others (the cloud).
We’ll discuss each of these next.
因此，务必使用服务器来运行生产环境的应用程序。一般来说，您可以通过两种方式访问​​服务器（两种应用程序托管方案）：
● 您可以购买并搭建自己的服务器（本地部署）。
● 您可以从其他服务商租用服务器（云端）。
接下来我们将分别讨论这两种方案。

On-Prem and Cloud Hosting
本地部署和云托管

The traditional way to run software is to buy servers and set them up on premises (on prem for short), in a physical location you own. When you are just starting out, the location could be as simple as a closet in your office, but as a company grows, so do the computing demands, and you eventually need a data center, with all the requisite equipment (e.g., racks, servers, hard drives, cooling) and staff (e.g., electricians, network administrators, security).So for decades, if you wanted to build a software company, you also had to invest quite a bit into hardware.
传统的软件运行方式是购买服务器并将其部署在公司内部（简称本地部署），也就是您拥有的物理位置。创业初期，这个位置可能只是办公室里的一个壁橱，但随着公司的发展，计算需求也会随之增长，最终您需要一个数据中心，配备所有必要的设备（例如机架、服务器、硬盘、冷却系统）和人员（例如电工、网络管理员、安保人员）。因此，几十年来，如果您想创办一家软件公司，就必须在硬件方面投入大量资金。

This started to change in 2006 with the launch of Amazon Web Services (AWS), the first cloud computing platform (cloud for short), which allowed you to rent servers using a software interface, either via a few clicks (which you’ll do in this chapter) or via a few lines of code (which you’ll do in Chapter 2). This profound shift let you get up and running in minutes instead of months, at the cost of a few cents (or even free) instead of thousands of dollars.
这种情况在 2006 年随着亚马逊网络服务 (AWS) 的推出而开始改变。AWS 是第一个云计算平台（简称云），它允许您通过软件界面租用服务器，只需点击几下鼠标（您将在本章中学习），或者编写几行代码（您将在第二章中学习）。这种深刻的变革让您只需几分钟即可启动并运行，而无需耗费数月时间，成本也从数千美元降至几美分（甚至免费）。

There are two main cloud offerings: infrastructure as a service (IaaS), which gives you access to low-level computing resources (servers, hard drives, networks), and leaves it up to you to put them together into a software delivery process, and platform as a service (PaaS), which gives you access to higher-level primitives, including an opinionated software delivery process. To get a feel for the difference, you’ll use a PaaS in the next section and an IaaS in the section after that.
云服务主要分为两大类：基础设施即服务 (IaaS) 和平台即服务 (PaaS)。IaaS 提供底层计算资源（服务器、硬盘、网络），但需要您自行将其组合成软件交付流程；PaaS 则提供更高级别的底层资源，包括预设的软件交付流程。为了更好地理解二者的区别，下一节将使用 PaaS，再下一节将使用 IaaS。

Example: Deploy an App via PaaS (Render)
示例：通过 PaaS（Render）部署应用
Popular PaaS providers include Heroku, Render, Fly.io, and Vercel (the book’s website provides a full list). Heroku was one of the first PaaS providers, and it used to be my go-to choice, but it discontinued its free tier in 2022. Therefore, for the examples in this book, you’ll be using Render, which offers a free Hobby tier and supports running apps in many languages and frameworks (including Node.js) without having to set up a build system or framework (topics you’ll learn about later in the book). Render also has a good reputation in the community and is often described as the spiritual successor to Heroku. To deploy the sample app by using Render, go through the following steps:
常用的 PaaS 提供商包括 Heroku、Render、Fly.io 和 Vercel（本书网站提供了完整列表）。Heroku 是最早的 PaaS 提供商之一，曾经是我的首选，但它已于 2022 年停止提供免费套餐。因此，本书示例中将使用 Render，它提供免费的 Hobby 套餐，并支持运行多种语言和框架（包括 Node.js）的应用，无需设置构建系统或框架（这些内容将在本书后续章节中介绍）。Render 在社区中也享有良好的声誉，并经常被誉为 Heroku 的精神继承者。要使用 Render 部署示例应用，请按照以下步骤操作：

Step 1: Sign up for a Render account
Create a new account on render.com.

Step 2: Deploy a new web service
步骤 2：部署新的 Web 服务
Head to the Render Dashboard and click the Deploy a Web Service button. On the next page, select the Public Git Repository tab and enter the URL of this book’s repo, https://github.com/brikis98/devops-book, as shown in Figure 1-1. This repo contains the Node.js code from Example 1-1 in the ch1/sample-app folder, so this lets you deploy the app without creating your own GitHub repo.
前往 Render 控制面板，然后单击“部署 Web 服务”按钮。在下一页中，选择“公共 Git 仓库”选项卡，然后输入本书仓库的 URL：https://github.com/brikis98/devops-book，如图 1-1 所示。此仓库包含示例 1-1 中 ch1/sample-app 文件夹下的 Node.js 代码，因此您无需创建自己的 GitHub 仓库即可部署应用程序。

Figure 1-1. Use this book’s sample code repo to create a web service in Render
图 1-1：使用本书的示例代码仓库在 Render 中创建 Web 服务

GET YOUR HANDS DIRTY
Here are a few exercises you can try at home to go deeper:
Click the Scale tab to change how many servers run your app.
Click the Logs tab to see the logs for your app.
Click the Metrics tab to see metrics for your app.
动手实践
以下是一些您可以在家尝试的练习，帮助您更深入地了解：
点击“规模”选项卡，更改运行应用程序的服务器数量。
点击“日志”选项卡，查看应用程序的日志。
点击“指标”选项卡，查看应用程序的指标。

When you’re done experimenting with Render, undeploy your app by clicking the Settings tab, scrolling to the bottom, and clicking the Delete Web Service button.
当您完成 Render 的实验后，请取消部署您的应用。方法是：点击“设置”选项卡，滚动到页面底部，然后点击“删除 Web 服务”按钮。

Using a PaaS typically means you get not just a server, but a lot of powerful functionality out of the box: scaling to multiple servers, domain names (<NAME>.onrender.com), encryption (HTTPS URLs), monitoring (logs and metrics), and more. This is the power of PaaS: in a matter of minutes, a good PaaS can take care of so many software delivery concerns for you. It’s like magic. And that’s the greatest strength of PaaS: it just works.
使用 PaaS 通常意味着您不仅可以获得服务器，还能获得许多开箱即用的强大功能：可扩展到多台服务器、域名 (<NAME>.onrender.com)、加密（HTTPS URL）、监控（日志和指标）等等。这就是 PaaS 的强大之处：只需几分钟，一个优秀的 PaaS 就能帮您解决许多软件交付方面的问题。简直就像魔法一样。而这正是 PaaS 最大的优势：它开箱即用。

Except when it doesn’t. When that happens, this same magic becomes the greatest weakness of PaaS. By design, with a PaaS, just about everything is happening behind the scenes, so if something doesn’t work, debugging or fixing it can be hard. Moreover, to make the magic possible, most PaaS offerings have limitations on what you can deploy, what types of apps you can run, what sort of access you can have to the underlying hardware, what sort of hardware is available, and so on. If the PaaS doesn’t support it—if the command-line interface (CLI) or UI the PaaS provides doesn’t expose the ability to do something you need—you typically can’t do it at all.
但也有例外。一旦出现问题，这种“魔法”就变成了 PaaS 最大的弱点。由于 PaaS 的设计理念是所有操作都在后台进行，因此如果出现问题，调试或修复可能会非常困难。此外，为了实现这些功能，大多数 PaaS 服务都会对部署内容、运行的应用类型、底层硬件的访问权限、可用硬件类型等进行限制。如果 PaaS 服务不支持某些功能——例如，如果其提供的命令行界面 (CLI) 或用户界面 (UI) 无法实现所需功能——通常情况下，您根本无法完成该操作。

As a result, while many projects start on PaaS, if they grow big enough and require more control, they end up migrating to IaaS.
因此，虽然许多项目最初都基于 PaaS 平台，但如果规模足够大，需要更多控制权，最终都会迁移到 IaaS 平台。

Example: Deploy an App via IaaS (AWS)
示例：通过 IaaS（AWS）部署应用程序
Broadly speaking, the IaaS space falls into three buckets: 
总的来说，IaaS 领域可以分为三大类：


Virtual private server
Some companies primarily focus on giving you access to a virtual private server (VPS) for as cheap as possible. These companies might offer a few other features (e.g., networking, storage) as well, but the main reason you’d go with one of these providers is that you just want a replacement for having to rack your own servers, and you prefer to have someone else do it for you and give you access. Some of the big players in this space include Hetzner, DigitalOcean, Vultr, and Akamai Connected Cloud (the book’s website provides a full list).
虚拟专用服务器 (VPS)
一些公司主要致力于以尽可能低的价格提供虚拟专用服务器 (VPS) 服务。这些公司可能还会提供一些其他功能（例如网络、存储），但您选择这些提供商的主要原因在于，您只是想省去自行搭建服务器的麻烦，并且更倾向于让别人来帮您完成这些工作并提供访问权限。该领域的一些主要参与者包括 Hetzner、DigitalOcean、Vultr 和 Akamai Connected Cloud（本书网站提供了完整列表）。


Content delivery networks
Other companies primarily focus on content delivery networks (CDNs), which are servers that are distributed all over the world, typically for serving and caching content.
Again, these companies might offer a few other features (e.g., protection against attacks), but the main reason you’d go with one of these providers is that your user base is geographically distributed, and you need a fast and reliable way to serve them content with low latency. You’ll learn all about CDNs in Chapter 9.
内容分发网络 (CDN)
其他公司主要专注于内容分发网络 (CDN)，CDN 是由分布在全球各地的服务器组成的网络，通常用于提供和缓存内容。这些公司可能还会提供一些其他功能（例如，攻击防护），但选择这些提供商的主要原因在于您的用户群分布在不同的地理位置，您需要一种快速可靠且低延迟的内容分发方式。您将在第 9 章中详细了解 CDN。

Cloud providers
Finally, a handful of large companies are trying to provide general-purpose cloud solutions that offer everything: VPS, CDN, containers, serverless, data storage, file storage, machine learning, natural language processing, edge computing, and more. The big players in this space include AWS, Google Cloud, and Microsoft Azure (full list).
云服务提供商
最后，一些大型公司正尝试提供涵盖所有功能的通用云解决方案：VPS、CDN、容器、无服务器架构、数据存储、文件存储、机器学习、自然语言处理、边缘计算等等。该领域的主要参与者包括 AWS、Google Cloud 和 Microsoft Azure（完整列表）。

In general, the VPS and CDN providers are specialists in their respective areas, so in those areas, they will typically beat a general-purpose cloud provider in terms of features, pricing, and user experience. For example, a VPS from Hetzner is usually faster, cheaper, and in some ways easier to use than one from AWS. So if you need only those specific items, you’re better off going with a specialist.However, if you’re building the infrastructure for an entire company, your architecture usually needs many types of infrastructure, and the general-purpose cloud providers will typically be a better fit, as they offer a one-stop-shop to meet all your needs.
一般来说，VPS 和 CDN 提供商都是各自领域的专家，因此在这些领域，它们通常在功能、价格和用户体验方面优于通用云服务提供商。例如，Hetzner 的 VPS 通常比 AWS 的 VPS 更快、
但是，如果您要为整个公司构建基础设施，您的架构通常需要多种类型的基础设施，而通用云服务提供商通常更合适，因为它们提供一站式服务来满足您的所有需求。

For the examples in this book, the IaaS provider you’ll be using is AWS, which offers a free tier and provides a huge range of reliable and scalable cloud services (servers, serverless, containers, databases, load balancers, etc.), so you can use it for most of the examples in this book. In addition, AWS is widely recognized as the dominant cloud provider—it has a 31% share of the market and has been the leader in the Gartner Magic Quadrant for the last 13 years—so it’s something you’re likely to use at work.
本书示例中，您将使用 AWS 作为 IaaS 提供商。AWS 提供免费套餐，并提供种类繁多、可靠且可扩展的云服务（服务器、无服务器架构、容器、数据库、负载均衡器等），因此本书中的大部分示例都适用于 AWS。此外，AWS 被公认为领先的云提供商——它拥有 31% 的市场份额，并且连续 13 年位居 Gartner 魔力象限榜首——因此，您在工作中很可能也会用到它。

AN AWS ACCOUNT IS REQUIRED TO PROCEED!
This book includes examples that deploy into AWS. To run these examples, you need an AWS account you can authenticate to with administrator access. If you don’t already have an AWS account, or you don’t know how to authenticate to it, check out the “How to Authenticate to AWS with IAM Identity Center” tutorial on this book’s website to learn how to create an AWS account (for free), create a user account with sufficient permissions, and authenticate to AWS on both the web and the command line.
您需要一个 AWS 账户才能继续！
本书包含部署到 AWS 的示例。要运行这些示例，您需要一个具有管理员权限的 AWS 账户。如果您还没有 AWS 账户，或者不知道如何进行身份验证，请访问本书网站，查看“如何使用 IAM Identity Center 对 AWS 进行身份验证”教程，了解如何创建 AWS 账户（免费）、创建具有足够权限的用户账户，以及如何通过 Web 和命令行对 AWS 进行身份验证。



由于需要美国相关信息，暂时没有进行AWS 演练




THE CLOUD VENDOR LOCK-IN MYTH
云供应商锁定误区
Many companies worry about vendor lock-in, where a cloud vendor suddenly increases pricing, but you can’t do anything about it, because it’s too expensive to migrate all your infrastructure. A persistent myth says the way to prevent this sort of lock-in is to use only generic services (e.g., virtual servers) and to avoid any of the cloud vendor’s proprietary services (e.g., managed databases, file stores, machine learning tools), which will make it “easy” to migrate to another vendor’s generic services. In most cases, this is a waste of time.
许多公司担心供应商锁定，即云供应商突然提高价格，而你却无能为力，因为迁移所有基础设施成本太高。一个长期存在的误区是，避免这种锁定的方法是只使用通用服务（例如虚拟服务器），避免使用云供应商的任何专有服务（例如托管数据库、文件存储、机器学习工具），这样就能“轻松”迁移到其他供应商的通用服务。但在大多数情况下，这纯属浪费时间。

If you use only generic services, you’ll end up creating your own bespoke versions of the proprietary services, so your initial deployment will take x months longer. If you have to migrate later, in theory, you won’t have to rewrite your code to work with the proprietary services of the new vendor, which might save you y months, and in the best-case scenario, y > x. However, in practice, using proprietary services lets you launch considerably faster (x is large), and you typically have to make major changes to your bespoke tooling to get it to work in another deployment environment (y is small), so you’d be lucky to break even (y = x).
如果你只使用通用服务，最终你将不得不创建专有服务的定制版本，因此你的初始部署时间将延长 x 个月。理论上，如果你以后必须迁移，你无需重写代码来兼容新供应商的专有服务，这或许可以节省 y 个月的时间，在最佳情况下，y > x。然而，在实践中，使用专有服务虽然能显著加快上线速度（x 值较大），但通常需要对定制工具进行重大修改才能使其在其他部署环境中运行（y 值较小），因此最终可能难以收回成本（y = x）。

That means you’re paying a guaranteed higher cost x up front to maybe save y time later, which is usually a bad trade-off (a lower expected value, in probability terms).
这意味着您需要预先支付更高的成本 x，才能在后期节省 y 的时间，这通常是一种不划算的权衡（从概率角度来看，预期收益较低）。

Unless you end up migrating many times, you’re typically better off picking the best tooling available (e.g., if you’re deploying to the cloud, using the cloud vendor’s proprietary services) and getting live as quickly as possible.
除非您需要多次迁移，否则通常最好选择最佳的可用工具（例如，如果您要部署到云端，则使用云供应商的专有服务），并尽快上线。

It’s worth mentioning that it doesn’t have to be cloud versus on prem; it can also be cloud and on prem, as discussed next.
值得一提的是，混合部署并非必须是云端与本地部署的对立；它也可以同时包含云端和本地部署，这一点将在下文讨论。

When to go with hybrid
何时选择混合部署
In a hybrid deployment, you use a mixture of cloud and onprem.
The most common use cases for this are the following:
在混合部署中，您可以结合使用云端和本地部署。最常见的用例如下：

Partial cloud migration
Some companies migrate a subset of their apps (including all new apps) to the cloud, but they keep some apps on prem, either temporarily (as a full migration can take years) or permanently (some apps are not worth the cost to migrate).
部分云迁移
一些公司会将部分应用程序（包括所有新应用程序）迁移到云端，但会将部分应用程序保留在本地，可能是暂时保留（因为完全迁移可能需要数年时间），也可能是永久保留（因为某些应用程序的迁移成本过高）。

Right tool for the job
You may choose to use the cloud when it’s a good fit (e.g., an app that needs elasticity) and to use on prem when it’s a good fit (e.g., an app with steady traffic patterns). Use the right tool for the job!
选择合适的工具
您可以选择在云部署适合特定需求时使用云部署（例如，需要弹性扩展的应用程序），也可以选择在本地部署适合特定需求时使用本地部署（例如，流量稳定的应用程序）。选择合适的工具至关重要！

My goal is to allow you to try out the examples in this book as quickly and cheaply as possible, so the cloud is the right tool for this job. Therefore, while the underlying concepts will apply to both the cloud and on prem, most of the examples in this book use the cloud. And if you’re going to use the cloud, you need to know when to use IaaS versus PaaS.
我的目标是让您能够以尽可能快且低成本的方式尝试本书中的示例，因此云部署是完成这项工作的理想工具。因此，虽然基本概念适用于云端和本地部署，但本书中的大多数示例都使用云端。如果您打算使用云端，则需要了解何时使用 IaaS，何时使用 PaaS。

IaaS Versus PaaS
If you’re using the cloud, when should you go with IaaS, and when should you go with PaaS? To start answering this question, let’s look at the key reasons to go with PaaS.
IaaS 与 PaaS
如果您正在使用云服务，那么何时应该选择 IaaS，何时应该选择 PaaS 呢？为了回答这个问题，我们先来看看选择 PaaS 的关键原因。

When to go with PaaS
This may seem like a strange thing to say in a book about DevOps and software delivery, but if you can create a great product without having to invest much in DevOps and software delivery, that’s a good thing. Your customers don’t care what kind of deployment pipeline you have, or whether you are running a fancy Kubernetes cluster or the newest type of database. All that matters is that you can create a product that meets your customers’ needs.
何时选择 PaaS
在一本关于 DevOps 和软件交付的书中提到这一点可能有点奇怪，但如果您无需在 DevOps 和软件交付方面投入太多资源就能打造出色的产品，那当然是件好事。您的客户并不关心您采用的是哪种部署流水线，也不关心您运行的是复杂的 Kubernetes 集群还是最新的数据库。他们只关心您能否打造出满足客户需求的产品。

KEY TAKEAWAY 3
You should spend as little time on software delivery as you possibly can while still meeting your company’s requirements.	
要点三
在满足公司需求的前提下，您应该尽可能减少软件交付所花费的时间。

If you can find someone else who can take care of software delivery for you and still meet your requirements, you should take advantage of that as much as possible. And that’s precisely what a good PaaS offers: out-of-the-box software delivery. If you can find a PaaS that meets your requirements, you should use it, stick with it for as long as you can, and avoid having to re-create all those software delivery pieces until you absolutely have to. PaaS is a good choice in these cases:
如果你能找到其他可以帮你处理软件交付并满足你需求的合作伙伴，就应该尽可能地利用这一点。而这正是优秀的PaaS平台所提供的：开箱即用的软件交付。如果你能找到符合你需求的PaaS平台，就应该使用它，尽可能长时间地坚持使用，避免在绝对必要之前重新构建所有软件交付组件。PaaS在以下情况下是一个不错的选择：

Side projects
If you’re working on a side project, the last thing you want to do is kill your passion for that project by spending all your time fighting with builds or pipelines or networking. Instead, let a PaaS do the heavy lifting.
业余项目
如果你正在进行一个业余项目，你最不想看到的就是因为把所有时间都花在构建、流水线或网络维护上而扼杀了你对这个项目的热情。相反，让PaaS平台来承担这些繁重的工作吧。

Startups and small companies
If you’re building a new company, you should almost always start with a PaaS. Startups are a race against time: can you build something the market wants before you run out of money? As you saw earlier in this chapter, you can get live on a PaaS in minutes, and for most startups, the scalability, availability, security, and compliance needs are minimal, so you can keep running on a PaaS for years before you run into the limitations. It’s only when you find product/market fit and start hitting the problem of having to scale your company—which is a good problem to have—that you may need to move off PaaS.
初创公司和小公司
如果你正在创建一家新公司，几乎总是应该从PaaS平台入手。初创公司是一场与时间的赛跑：你能否在资金耗尽之前打造出市场需要的产品？正如本章前面所述，您可以在几分钟内上线 PaaS 平台。对于大多数初创公司而言，其可扩展性、可用性、安全性和合规性需求都相对较低，因此您可以长期使用 PaaS 平台，而不会遇到任何限制。只有当您找到产品/市场契合点并开始面临公司规模扩张的问题时（这当然是好事），您才可能需要迁移到其他平台。

New and experimental projects
If you’re at an established company that has a slow software delivery process, using a PaaS can be a great way to quickly try out new and experimental projects, especially if those projects don’t have the same scalability, availability, security, and compliance needs as your company’s more mature products.
新项目和实验性项目
如果您所在的公司软件交付流程较为缓慢，那么使用 PaaS 平台可以快速尝试新的实验性项目，尤其是在这些项目对可扩展性、可用性、安全性和合规性的需求与公司成熟产品不同的情况下。

As a general rule, you want to use a PaaS whenever you can, and move on to IaaS only when a PaaS can no longer meet your requirements, as per the next section.
一般来说，您应该尽可能使用 PaaS 平台，只有当 PaaS 平台无法满足您的需求时才应迁移到 IaaS 平台，具体内容请参见下一节。

When to go with IaaS
何时选择 IaaS
In the following cases, an IaaS is usually a better fit:
以下情况下，IaaS 通常是更合适的选择：

Load
If you’re dealing with a lot of traffic, PaaS pricing may become prohibitively expensive. Moreover, PaaS usually limits the types of apps and architectures you can use, so you may have to migrate to IaaS to scale your systems.
负载
果您需要处理大量流量，PaaS 的定价可能会变得非常昂贵。此外，PaaS 通常会限制您可以使用的应用程序类型和架构，因此您可能需要迁移到 IaaS 来扩展系统。

Company size
As you shift from a handful of developers to dozens of teams with hundreds of developers, not only can PaaS pricing become untenable, but you may also hit limits with governance and access controls (e.g., allowing some teams to make some types of changes but not others).
公司规模
您的开发人员从少数几人发展到数十个团队、数百名开发人员时，PaaS 的定价不仅会变得难以承受，而且您还可能遇到治理和访问控制方面的限制（例如，允许某些团队进行某些类型的更改，但不允许进行其他类型的更改）。

Availability
Your business may need to provide uptime guarantees that are higher than what your PaaS can provide. Moreover, when your app has an outage or a bug, PaaS offerings are often limited in the type of visibility and connectivity options they provide (e.g., Heroku doesn’t let you connect to servers over SSH), so you may have to migrate to IaaS to improve your ability to debug and introspect your systems.
可用性
您的业务可能需要提供比 PaaS 更高的正常运行时间保证。此外，当您的应用程序出现故障或错误时，PaaS 产品提供的可见性和连接选项通常有限（例如，Heroku 不允许您通过 SSH 连接到服务器），因此您可能需要迁移到 IaaS 来提高调试和自检系统的能力。

Security and compliance
One of the most common reasons to move off PaaS is that most of them (with the notable exception of Aptible) do not provide sufficient visibility, access, or control to meet security and compliance requirements (e.g., SOC 2, ISO 27001, PCI DSS).
安全性和合规性
放弃 PaaS 的最常见原因之一是，大多数 PaaS 服务（Aptible 是个例外）无法提供足够的可见性、访问权限或控制权来满足安全性和合规性要求（例如 SOC 2、ISO 27001、PCI DSS）。

You go with IaaS whenever you need more control, more performance, and/or more security. If your company gets big enough, one or more of these needs will likely push you from PaaS to IaaS; that’s just the price of success.
当您需要更强的控制力、更高的性能和/或更高的安全性时，就应该选择 IaaS。如果您的公司规模足够大，上述一项或多项需求很可能会促使您从 PaaS 转向 IaaS；这就是成功的代价。

KEY TAKEAWAY 4
Go with PaaS whenever you can; go with IaaS when you have to.
要点四
尽可能选择PaaS；只有在不得不选择IaaS时才选择IaaS。

Now that you’ve had a chance to do a basic app deployment and compare hosting options, the question is, what happens next? How will your architecture and processes change as your company grows? This is the topic of the next section.
现在您已经有机会进行基本的应用程序部署并比较了托管选项，那么接下来会发生什么呢？随着公司的发展，您的架构和流程将如何变化？这就是下一节的主题。

The Evolution of DevOps
DevOps 的演进
While writing my first book, Hello, Startup (O’Reilly), I interviewed early employees from some of the most successful companies of the last 20 years, including Google, Facebook, LinkedIn, Twitter, GitHub, Stripe, Instagram, Pinterest, and many others. One thing that struck me is that the architecture and software delivery processes at just about every one of these software companies evolved along similar lines. They had individual differences here and there, but far more similarities than differences, and the broad shape of the evolution repeated again and again. In this section, I share this evolutionary process, broken into nine high-level steps.
在撰写我的第一本书《你好，创业公司》（Hello, Startup，O’Reilly 出版）时，我采访了过去 20 年里一些最成功公司的早期员工，包括 Google、Facebook、LinkedIn、Twitter、GitHub、Stripe、Instagram、Pinterest 等等。令我印象深刻的一点是，几乎所有这些软件公司的架构和软件交付流程都沿着相似的路径演进。它们之间虽存在一些差异，但相似之处远多于不同之处，而且演进的总体轮廓不断重复出现。在本节中，我将分享这一演进过程，并将其分解为九个主要步骤。

If you’re new to DevOps and software delivery, you may be unfamiliar with some of the terms used here. Don’t panic.The idea is to start with a top-down overview—a bit like a high-level map—to help you understand the various ingredients and how they fit together. You can think of this content as a high-level preview of the topics you’ll cover in the following chapters. As you go through each chapter, you’ll zoom in on each of these topics, study each one in detail, and try most of them out with real examples. You can then zoom back out and revisit this high-level map at any time to see the big picture and get your bearings again.
如果您是 DevOps 和软件交付的新手，您可能对这里使用的一些术语不太熟悉。别担心。我们的目标是从自上而下的概述入手——有点像一张高层次的地图——帮助您理解各种要素以及它们如何相互关联。您可以将这部分内容视为对后续章节主题的概览。在学习每一章的过程中，您将深入了解每个主题，进行详细学习，并通过实际案例来实践其中的大部分内容。之后，您可以随时回顾整体框架，重新审视全局，理清思路。

Let’s begin with step 1, as shown Figure 1-10, which is where most projects start, including new startups, new initiatives at established companies, and side projects.
让我们从步骤 1 开始，如图 1-10 所示，大多数项目都从这里开始，包括新创公司、成熟公司的新项目以及业余项目。

Single server
单服务器
All your application code runs on a single server.
所有应用程序代码都运行在单个服务器上。
ClickOps
You manage all your infrastructure and deployments manually.
您可以手动管理所有基础架构和部署。

Does this sound familiar? It’s what you just did earlier in this chapter, using Render and AWS. So congrats, you’ve completed step 1! But this is only the beginning. As traffic and team size grow, you move on to step 2, shown in Figure 1-11.
这听起来是不是很熟悉？这正是你在本章前面使用 Render 和 AWS 所做的。恭喜你，你已经完成了第一步！但这仅仅是个开始。随着流量和团队规模的增长，你将进入第二步，如图 1-11 所示。

Standalone database
As your database increasingly becomes the bottleneck, you move it onto a separate server (Chapter 9).
独立数据库
随着数据库逐渐成为瓶颈，您可以将其迁移到单独的服务器上（第 9 章）。

Version control
As your team grows, you use a version-control system to collaborate on your code and track all changes (Chapter 4).
版本控制
随着团队的壮大，您可以使用版本控制系统来协作编写代码并跟踪所有更改（第 4 章）。

Continuous integration
To reduce bugs and outages, you set up automated tests (Chapter 4) and continuous integration (Chapter 5).
持续集成
为了减少错误和故障，您可以设置自动化测试（第 4 章）和持续集成（第 5 章）。

As traffic continues to grow, you move on to step 3, shown in Figure 1-12.
随着流量持续增长，您将进入步骤 3，如图 1-12 所示。

Multiple servers
As traffic increases further, a single server is no longer enough, so you run your app across multiple servers (Chapter 3).
多服务器
随着流量的进一步增长，单个服务器已无法满足需求，因此您需要在多台服务器上运行应用程序（第 3 章）。

Load balancing
You distribute traffic across the servers by using a load balancer (Chapter 3).
负载均衡
您可以使用负载均衡器将流量分配到各个服务器（第 3 章）。

Networking
To protect your servers, you put them into a private network (Chapter 7).
网络
为了保护您的服务器，您需要将它们置于私有网络中（第 7 章）。

Data management
You set up schema migrations and backups for your data stores (Chapter 9).
数据管理
您需要为数据存储设置模式迁移和备份（第 9 章）。

Monitoring
To get better visibility into your systems, you set up monitoring (Chapter 10).
监控
为了更好地了解您的系统，您需要设置监控（第 10 章）。

Most software projects never need to make it past these first three steps. If you’re one of them, don’t fret: this is a good thing. The first three steps are relatively simple. The technologies involved are fast to learn, easy to set up, and fun to work with. If you’re forced into the subsequent steps, it’s because you’re facing new problems that require morecomplex architectures and processes to solve, and this additional complexity has a considerable cost. If you aren’t facing those problems, you can, and should, avoid that cost.
大多数软件项目都不需要经历前三个步骤之后的阶段。如果你的项目也属于这种情况，不必担心：这其实是件好事。前三个步骤相对简单，涉及的技术也易于学习、设置和使用。如果你被迫进入后续步骤，那是因为你遇到了新的问题，需要更复杂的架构和流程来解决，而这种额外的复杂性会带来相当大的成本。如果你没有遇到这些问题，那么你可以而且应该避免这些成本。

That said, larger, more established companies, with more users, may have to move on to step 4, shown in Figure 1- 13.
话虽如此，规模更大、更成熟的公司，以及拥有更多用户的公司，可能需要进入图 1-13 所示的第四步。

Caching for data stores
数据存储缓存
Your database continues to be a bottleneck, so you add read replicas and caches (Chapter 9).
您的数据库仍然是瓶颈，因此您添加了只读副本和缓存（第 9 章）。

Caching for static content
静态内容缓存
As traffic continues to grow, you add a content delivery network (CDN) to cache content that doesn’t change often (Chapter 9).
At this point, your team size is often the biggest problem, so you have to move on to step 5, shown in Figure 1-14.
随着流量持续增长，您添加了内容分发网络 (CDN) 来缓存不经常更改的内容（第 9 章）。
此时，团队规模通常是最大的问题，因此您必须进入步骤 5，如图 1-14 所示。

Multiple environments
To help teams do better testing, you set up multiple environments (e.g., dev, stage, prod), each of which has a full copy of your infrastructure (Chapter 6).
多环境
为了帮助团队更好地进行测试，您可以设置多个环境（例如，开发环境、测试环境、生产环境），每个环境都拥有完整的基础架构副本（第 6 章）。

Continuous delivery
To make deployments faster and more reliable, you set up continuous delivery (Chapter 5).
持续交付
为了使部署更快、更可靠，您可以设置持续交付（第 5 章）。

Secure communication and storage
To keep all the new environments secure, you work on secrets management and encrypting all data at rest and in transit (Chapter 8).
安全通信和存储
为了确保所有新环境的安全，您可以进行密钥管理，并对所有静态和传输中的数据进行加密（第 8 章）。

As your teams keep growing, to be able to keep moving quickly, you will need to update your architecture and processes to step 6, as shown in Figure 1-15.
随着团队的不断壮大，为了能够继续快速发展，您需要将架构和流程更新到步骤 6，如图 1-15 所示。

Microservices
To allow teams to work more independently, you break your monolith into multiple microservices, each with its own data stores and caches (Chapter 6).
微服务
为了让团队能够更独立地工作，您可以将单体应用拆分成多个微服务，每个微服务都有自己的数据存储和缓存（第 6 章）。

Infrastructure as code
Maintaining this many environments manually is hard, so you start to manage your infrastructure as code (Chapter 2).
基础设施即代码
手动维护如此多的环境非常困难，因此您开始使用代码来管理基础设施（第 2 章）。

These steps represent a significant increase in complexity: your architecture has more moving parts, your processes are more complicated, and you most likely need a dedicated infrastructure team to manage all this. For a small percentage of companies—typically, large enterprises with massive user bases—even this isn’t enough, and you are forced to move on to step 7, shown in Figure 1-16.
这些步骤显著增加了复杂性：您的架构包含更多组件，流程更加复杂，而且您很可能需要一个专门的基础设施团队来管理所有这些。对于一小部分公司——通常是拥有庞大用户群的大型企业——即使这样也不够，您不得不进入步骤 7，如图 1-16 所示。

Service discovery
As the number of microservices increases, you set up a service discovery system to help them communicate with one another (Chapter 7).
服务发现
随着微服务数量的增加，您需要搭建一个服务发现系统来帮助它们彼此通信（第 7 章）。

Observability
To get even more visibility into your microservices, you start using structured events, tracing, and observability tools (Chapter 10).
可观测性
为了更深入地了解您的微服务，您需要开始使用结构化事件、追踪和可观测性工具（第 10 章）。

Hardening
To meet various compliance standards (e.g., NIST, CIS, PCI), you work on server and network hardening (Chapters 7 and 8).
加固
为了满足各种合规性标准（例如 NIST、CIS、PCI），您需要进行服务器和网络加固（第 7 章和第 8 章）。

Microservice mesh
With even more microservices, you start using service mesh tools as a unified solution for the preceding items (observability, service discovery, hardening), as well as for traffic control and error handling (Chapter 7).
微服务网格
随着微服务数量的进一步增加，您需要开始使用服务网格工具，将其作为统一的解决方案，用于上述各项（可观测性、服务发现、加固），以及流量控制和错误处理（第 7 章）。

Large companies produce a lot of data, and the need to analyze and leverage this data leads to step 8, shown in Figure 1-17.
大型公司会产生大量数据，而分析和利用这些数据的需求导致了步骤 8，如图 1-17 所示。

Analytics tools
To be able to process and analyze your company’s data, you set up data warehouses, big data systems, and fast data systems (Chapter 9).
分析工具
为了能够处理和分析公司的数据，您需要搭建数据仓库、大数据系统和快速数据系统（第 9 章）。

Event streams
With even more microservices communication and more data to move around, you set up an event-streaming platform and move to an event-driven architecture (Chapter 9).
事件流
随着微服务通信的日益频繁和需要传输的数据量不断增加，您需要搭建事件流平台并转向事件驱动架构（第 9 章）。

Feature toggles
You start using feature toggles in your code to A/B test new features and to make deployments more reliable (Chapter 5).	
功能开关
您开始在代码中使用功能开关来测试新功能，并提高部署的可靠性（第 5 章）。

Finally, as your user base and employee base keeps growing, you move on to step 9, shown in Figure 1-18.
最后，随着用户群和员工群的不断增长，您将进入步骤 9，如图 1-18 所示。

Multiple data centers
To handle a global user base, you set up multiple data centers around the world (Chapter 6).
多个数据中心
为了服务全球用户群，您在世界各地建立了多个数据中心（第 6 章）。

Advanced networking
You connect all your data centers together over the network (Chapter 7).
高级网络
您将所有数据中心通过网络连接起来（第 7 章）。

Internal developer platform
To help boost developer productivity and to standardize coding practices, you set up an internal developer platform (Chapter 11).
内部开发者平台
为了提高开发者的工作效率并规范编码实践，您建立了一个内部开发者平台（第 11 章）。

These last three steps are for companies that face the toughest problems and have to deal with the most complexity: global deployments, thousands of developers, millions of customers. Even the architecture you see in step 9 is still a simplification compared to what the top 0.1% of companies face, but if that’s where you’re at, you’ll need more than this introductory book!
最后这三个步骤适用于面临最棘手问题、需要处理最复杂情况的公司：全球部署、数千名开发人员、数百万客户。即使是步骤 9 中展示的架构，与顶尖 0.1% 的公司所面临的情况相比，仍然是一种简化。但如果您正处于这样的阶段，那么这本入门书籍将远远不够！

Now that you’ve seen all the steps, you should keep in mind two points. First, these steps are a simplification. I’ve presented them as discrete, self-contained, one-time actions to make the process easier to learn, but in the real world, you may find more of a continuum than discrete steps, the steps may happen in a different order, and a single step may be divided into many parts and developed over a long period of time. For example, instead of trying to introduce infrastructure as code all at once in step 6, it’s sometimes more effective to introduce a minimal amount of infrastructure as code in step 2, a bit more in step 3, even more in step 4, and so on, incrementally building up to managing everything as code by step 6. I hope this is a helpful mental model of how DevOps typically evolves within a company, but never forget it’s just a model.
既然您已经了解了所有步骤，请记住两点。首先，这些步骤是一种简化。我将它们呈现为独立的、自包含的、一次性的操作，是为了方便您学习。但在实际应用中，您可能会发现它们更像是一个连续的过程，而非孤立的步骤；步骤的顺序可能有所不同；单个步骤也可能被拆分成多个部分，并在较长时间内逐步完善。例如，与其尝试在步骤 6 中一次性引入基础设施即代码，有时更有效的做法是在步骤 2 中引入少量基础设施即代码，在步骤 3 中引入更多，在步骤 4 中进一步引入，依此类推，逐步构建，最终在步骤 6 中实现所有基础设施即代码的管理。我希望这个模型能够帮助您更好地理解 DevOps 在公司内部的典型发展过程，但请记住，这仅仅是一个模型。

All models are wrong, but some are useful.
—George E. P. Box
所有模型都是错误的，但有些是有用的。
——乔治·E·P·博克斯

Second, you should expect change. There’s no one best practice or one right way to “do DevOps.” Your architecture and processes need to be adapted to your company’s needs, and those needs will change. Be aware of it, plan for it, embrace it. One of the hallmarks of great software is that it is adaptable. Great code, great architectures, and great processes are, above all else, easy to change. And the very first change may be adopting DevOps practices in the first place, which is the focus of the next section.
其次，你要做好应对变化的准备。没有所谓的最佳实践，也没有“DevOps 的唯一正确方法”。你的架构和流程需要根据公司的需求进行调整，而这些需求本身也会不断变化。要意识到这一点，做好规划，并欣然接受。优秀软件的标志之一就是其适应性。优秀的代码、优秀的架构和优秀的流程，最重要的是，它们都易于更改。而第一个变化可能就是首先采用 DevOps 实践，这也是下一节的重点。

Adopting DevOps Practices
As you read through the nine steps, the idea is to match your company to one of the steps and to pursue the architecture and processes in that step. What you don’t want to do is to immediately jump to the end and use the architecture and processes of the largest companies. Let’s be honest here: your company probably isn’t Google or Netflix; you don’t have the same scale, you don’t have the same problems to solve, and therefore, the same solutions won’t be a good fit. In fact, adopting the solutions for a different stage of company may be actively harmful. Every time I see a three-person startup running an architecture with 12 microservices, Kubernetes, a service mesh, and an event-streaming platform, I just shake my head; they’re paying a massive cost to solve problems they don’t have.
采用 DevOps 实践
在阅读这九个步骤时，关键在于找到与贵公司相匹配的步骤，并采用该步骤中推荐的架构和流程。切忌直接跳到最后，照搬大型公司的架构和流程。说实话，贵公司很可能不是谷歌或 Netflix；你们的规模不同，需要解决的问题也不同，因此，同样的解决方案并不适用。事实上，照搬其他发展阶段的解决方案甚至可能适得其反。每次看到一个三人创业公司运行着包含 12 个微服务、Kubernetes、服务网格和事件流平台的架构时，我都会摇头叹息；他们为了解决根本不存在的问题，付出了巨大的代价。

KEY TAKEAWAY 5
Adopt the architecture and software delivery processes that are appropriate for your stage of company.
要点五
采用适合公司发展阶段的架构和软件交付流程。

Even if you are a massive company, you still shouldn’t try to adopt every DevOps practice all at once. One of the most important lessons I’ve learned in my career is that most large software projects fail. Whereas roughly 3 out of 4 small IT projects (less than $1 million) are completed successfully, only 1 out of 10 large projects (greater than $10 million) are completed on time and on budget, and more than one-third of large projects are never completed at all.注2
即使你是一家规模庞大的公司，也不应该试图一次性采用所有 DevOps 实践。我职业生涯中最重要的经验之一是，大多数大型软件项目都会失败。虽然大约四分之三的小型 IT 项目（低于 100 万美元）能够成功完成，但只有十分之一的大型项目（超过 1000 万美元）能够按时按预算完成，超过三分之一的大型项目根本就无法完成。

This is why I get worried when I see the CEO or CTO of a large company give marching orders that everything must be migrated to the cloud, the old data centers must be shut down, and that everyone will “do DevOps” (whatever that means), all within six months. I’m not exaggerating when I say that I’ve seen this pattern several dozen times, and without exception, every single one of these initiatives has failed. Inevitably, two to three years later, every one of these companies is still working on the migration, the old data center is still running, and no one can tell whether they are really “doing DevOps” or not.
这就是为什么每当我看到大公司的CEO或CTO下达命令，要求所有业务必须在六个月内迁移到云端，旧数据中心必须关闭，并且所有人都要“推行DevOps”（不管这到底是什么意思）时，我都会感到担忧。毫不夸张地说，我已经见过这种模式几十次了，而且无一例外，每一次都以失败告终。不出所料，两三年后，这些公司仍在进行迁移，旧数据中心仍在运行，而没有人能确定他们是否真的在“推行DevOps”。

A more effective way to accomplish any large migration project is to do it incrementally. The key to incrementalism is not just splitting the work into a series of small steps, but splitting it in such a way that every step brings its own value—even if the later steps never happen. To understand why this is so important, consider the opposite—suppose that you have a huge migration project, broken into the following steps:
1. Redesign the UI.
2. Rewrite the backend.
3. Migrate the data.
更有效的迁移方法是循序渐进地进行。循序渐进的关键不仅在于将工作分解成一系列小步骤，更在于确保每个步骤都能带来价值——即使后面的步骤最终没有实施。为了理解这一点的重要性，不妨考虑一下相反的情况——假设你有一个庞大的迁移项目，分为以下步骤：
1. 重新设计用户界面 (UI)。
2. 重写后端。
3. 迁移数据。

You complete the first step, but you can’t launch the UI because it relies on the new backend in the second step.
你完成了第一步，但由于用户界面依赖于第二步中新搭建的后端，所以无法上线。

So, next, you rewrite the backend, but you can’t launch that either, until you migrate the data in the third step. Only when you complete all three steps can you get any value from this work. This is false incrementalism: you’ve split the work into smaller steps, but you get value only when all the steps are completed.3 This is a huge risk, as conditions change all the time, and the project may be paused or cancelled or modified partway through, before you’ve completed all the steps. If that happens, you get the worst possible outcome: you’ve invested a bunch of time and money but got nothing in return.
接下来，你重写了后端，但同样无法上线，直到完成第三步中的数据迁移。只有完成所有三个步骤，这项工作才能产生任何价值。这就是所谓的“伪增量”：你将工作拆分成更小的步骤，但只有完成所有步骤才能获得价值。³ 这存在巨大的风险，因为情况瞬息万变，项目可能在完成所有步骤之前就被暂停、取消或修改。如果这种情况发生，你将面临最糟糕的结果：投入了大量的时间和金钱，却一无所获。

Instead, you want each part of the project to deliver value so that even if the entire project doesn’t finish, no matter what step you completed, it was still worth doing. You can accomplish this by focusing on solving one, small, concrete problem at a time. For example, instead of trying to do a “big-bang” migration to the cloud, try to identify one team that is struggling and then work to migrate just that team.
相反，你希望项目的每个部分都能创造价值，这样即使整个项目最终未能完成，无论完成了哪个步骤，都仍然值得付出努力。你可以通过一次专注于解决一个具体、小的问题来实现这一点。例如，与其尝试“大爆炸式”地迁移到云端，不如先找出遇到困难的团队，然后集中精力帮助该团队完成迁移。

If you can get a quick win by fixing one real, concrete problem right away and making one team successful, you’ll begin to build momentum. This will allow you to go for another quick win, and another one after that, incrementally working through all the parts of the larger migration. But even if the larger migration is canceled, at least one team is more successful now, so it was still worth the investment.
如果你能通过立即解决一个实际存在的具体问题并帮助一个团队取得成功而获得快速的成效，你就能开始积累势头。这将使你能够争取下一个快速的成效，然后是下一个，逐步完成整个迁移过程。即使最终取消了整个迁移计划，至少也有一个团队现在更加成功了，所以之前的投入仍然是值得的。

KEY TAKEAWAY 6
Adopt DevOps incrementally, as a series of small steps, where each step is valuable by itself.
要点 6
逐步采用 DevOps，将其分解为一系列小步骤，每个步骤本身都具有价值。

Conclusion
结论
You now know the basics of deploying apps. Here are the six key takeaways from this chapter:
您现在已掌握应用部署的基础知识。本章的六个关键要点如下：

You should never expose apps running on a personal computer to the outside world
切勿将运行在个人电脑上的应用暴露给外部网络。
Instead, deploy those apps on a server.
相反，应将这些应用部署在服务器上。

Using the cloud should be your default choice for most new deployments these days
如今，对于大多数新部署，使用云服务应该是您的默认选择。
Run your server(s) in the cloud whenever you can. Use on prem only if you already have an on-prem presence or you have load patterns or compliance requirements that work best on-prem.
尽可能在云端运行服务器。仅当您已有本地部署环境，或者您的负载模式或合规性要求更适合本地部署时，才应使用本地部署。

You should spend as little time on software delivery as you possibly can while still meeting your company’s requirements 
在满足公司需求的前提下，应尽可能减少软件交付的时间。
If you can offload your software delivery to someone else while still responsibly meeting your company’s requirements, you should.
如果可以将软件交付外包给其他服务商，同时仍能负责任地满足公司需求，则应这样做。

Go with PaaS whenever you can; go with IaaS when you have to
尽可能选择 PaaS；仅在必要时选择 IaaS。
A PaaS lets you offload most of your software delivery needs, so if you can find a PaaS that meets your company’s requirements, you should use it. Go with an IaaS only if your company’s requirements exceed what a PaaS can offer.
PaaS 可以满足您的大部分软件交付需求，因此，如果您能找到满足公司需求的 PaaS，则应使用它。仅当公司需求超出 PaaS 的服务范围时，才应选择 IaaS。

Adopt the architecture and software delivery processes that are appropriate for your stage of company
根据公司所处阶段选择合适的架构和软件交付流程。
Always pick the right tools for the job.
始终选择合适的工具来完成工作。

Adopt DevOps incrementally, as a series of small steps, where each step is valuable by itself
逐步采用 DevOps，将其作为一系列小步骤，每个步骤本身都具有价值。
Avoid big-bang migrations and false incrementalism, which provide value only after all steps have been completed.
避免“大爆炸式”迁移和虚假的渐进主义，因为这些只有在所有步骤完成后才能产生价值。

One way to summarize these ideas is the concept of minimum effective dose. This is a term from pharmacology, where you use the smallest dose of medicine that will give you the biological response you’re looking for. That’s because just about every drug, supplement, and intervention becomes toxic at a high enough dose, so you want to use just enough to get the benefits, and no more.The same is true with DevOps: every architecture, process, and tool has a cost, so you want to use the simplest and most minimal solution that gives you the benefits you’re looking for, and no more. Don’t use a fancy architecture or software delivery process if a simpler one will do; instead, always aim for the minimum effective dose of DevOps.
可以用“最小有效剂量”的概念来概括这些理念。这个概念源于药理学，指的是使用能够产生所需生物反应的最小药物剂量。这是因为几乎所有药物、补充剂和干预措施在剂量过高时都会产生毒性，所以你只需要使用能够获得益处的剂量即可，不多不少。DevOps 也是如此：每种架构、流程和工具都有成本，因此你应该使用能够提供所需益处的最简单、最精简的解决方案，不多不少。如果更简单的架构或软件交付流程就能满足需求，就不要使用复杂的方案；相反，始终追求 DevOps 的最小有效剂量。

Knowing how to deploy your apps is an important step, but it’s just the first step in understanding DevOps and software delivery. Quite a few steps remain. One problem you may have noticed, for example, is that you had to deploy everything in this chapter by manually clicking around a web UI. Doing things manually is tedious, slow, and error prone. Imagine if instead of one app, you had to deploy ten, and you had to do it many times per day. Not fun.
了解如何部署应用程序固然重要，但这仅仅是理解 DevOps 和软件交付的第一步。后面还有很多步骤。例如，您可能已经注意到，本章中所有部署操作都必须通过手动点击 Web 用户界面来完成。手动操作既繁琐又缓慢，而且容易出错。试想一下，如果您需要部署的不是一个应用程序，而是十个，而且每天还要执行多次部署，那会是怎样一番景象？简直令人抓狂。

The solution is automation, and managing your infrastructure as code, which is the topic of Chapter 2.
解决方案是自动化，以及将基础设施作为代码进行管理，这正是第二章的主题。

————————————————————————————————————————————————————————————————
1 For example, Google Cloud’s 2022 price changes increased storage pricing by as much as 50%, and Vercel’s 2024 price changes increased pricing for some users by as much as 10 times.
1 例如，谷歌云在 2022 年的价格调整中，存储价格上涨了高达 50%，而 Vercel 在 2024 年的价格调整中，部分用户的价格上涨了高达 10 倍。

2 The Standish Group, “CHAOS Manifesto 2013: Think Big, Act Small,” 2013, https://oreil.ly/XGCzJ.
2 Standish 集团，“CHAOS Manifesto 2013: Think Big, Act Small”，2013 年，https://oreil.ly/XGCzJ。

3 Dan Milstein, “How to Survive a Ground-Up Rewrite Without Losing Your Sanity,” OnStartups, April 8, 2013, https://oreil.ly/lAeBz.
3 Dan Milstein，“如何在彻底重写代码的过程中保持理智”，OnStartups，2013 年 4 月 8 日，https://oreil.ly/lAeBz。


*************************************************************************
# Chapter 2. How to Manage Your Infrastructure as Code
# 第二章 如何以代码形式管理基础设施

In Chapter 1, you learned how to deploy your app by using PaaS and IaaS, but it required a lot of manual steps clicking around a web UI. This is fine while you’re learning and experimenting, but managing everything at a company this way—sometimes called ClickOps—quickly leads to problems:
在第一章中，您学习了如何使用 PaaS 和 IaaS 部署应用程序，但这需要手动点击 Web 用户界面进行大量操作。在学习和实验阶段，这当然没问题，但如果在公司范围内以这种方式管理所有事务（有时称为 ClickOps），很快就会出现问题：

Deployments are slow and tedious
部署缓慢且繁琐
You can’t deploy frequently or respond to problems or opportunities quickly.
您无法频繁部署，也无法快速响应问题或机遇。

Deployments are error prone and inconsistent
部署容易出错且不稳定
You end up with lots of bugs, outages, and late-night debugging sessions. You become fearful and slow to introduce new features.
最终会导致大量 bug、服务中断和深夜调试。您会变得畏首畏尾，不敢轻易推出新功能。

Only one person knows how to deploy
只有一个人知道如何部署
That person is overloaded and never has time for long-term improvements. If they were to leave or get hit by a bus, everything would grind to a halt.注1
这个人工作量巨大，根本没有时间进行长期改进。如果他离职或遭遇意外，一切都将停滞不前。注1

Fortunately, these days, there is a better way to do things:
幸运的是，如今有更好的方法：
you can manage your infrastructure as code (IaC). Instead of clicking around manually, you use code to define, deploy, update, and destroy your infrastructure. This represents a key insight of DevOps: most tasks that you used to do manually can now be automated using code, as shown in Table 2-1.
您可以将基础设施作为代码 (IaC) 进行管理。您无需手动点击操作，而是使用代码来定义、部署、更新和销毁您的基础设施。这体现了 DevOps 的一个关键理念：过去大多数手动执行的任务现在都可以使用代码实现自动化，如表 2-1 所示。

Table 2-1. A key insight of DevOps is that you can manage almost everything as code
表 2-1. DevOps 的一个关键理念是，几乎所有事情都可以用代码来管理。

Task | How tomanage as code | Example | Chapter
Provision servers|Provisioning tools|Use OpenTofu to eploy a server|This chapter
Configure servers|Server templating tools|Use Packer to create an image of a server|This chapter
Configure apps|Configuration files and services|Read configuration from a JSON file|Chapter 6
Configure networking|Softwaredefined networking|Use Istio as a service mesh|Chapter 7
Build apps|Build systems|Build your app with npm|Chapter 4|
Test apps |Automated tests|Write automated tests using Jest|Chapter 4
Deploy apps|Automated deployment|Do a rolling deployment with Kubernetes|Chapter 3
Scale apps|Auto scaling|Set up autoscaling policies in AWS|Chapter 3
Recover from outages|Auto healing|Set up liveness probes in ubernetes|Chapter 3
Manage databases|Schema migrations|Use Knex.js to update your database schema|Chapter 9
Test for compliance|Policy as code|Check compliance via Open Policy Agent|Chapter 4

任务 | 如何以代码形式管理 | 示例 | 章节
配置服务器 | 配置工具 | 使用 OpenTofu 部署服务器 | 本章
配置服务器 | 服务器模板工具 | 使用 Packer 创建服务器镜像 | 本章
配置应用 | 配置文件和服务 | 从 JSON 文件读取配置 | 第 6 章
配置网络 | 软件定义网络 | 使用 Istio 作为服务网格 | 第 7 章
构建应用 | 构建系统 | 使用 npm 构建应用 | 第 4 章
应用测试 | 自动化测试 | 使用 Jest 编写自动化测试 | 第 4 章
应用部署 | 自动化部署 | 使用 Kubernetes 进行滚动部署 | 第 3 章
应用扩展 | 自动扩展 | 在 AWS 中设置自动扩展策略 | 第 3 章
故障恢复 | 自动修复 | 在 Kubernetes 中设置存活探针 | 第 3 章
数据库管理 | 模式迁移 | 使用 Knex.js 更新数据库模式 | 第 9 章
合规性测试 | 策略即代码 | 通过 Open Policy Agent 检查合规性 | 第 4 章
	
If you search around, you’ll quickly find many tools that allow you to manage your infrastructure as code, including Chef, Puppet, Ansible, Pulumi, Terraform, OpenTofu, AWS, CloudFormation, Docker, and Packer. Which one should you use? Many of the comparisons you find online do little more than list the general properties of each tool and make it sound like you could be equally successful with any of them. And while that’s true in theory, it’s not true in practice. These tools differ considerably from one another, and your odds of success go up significantly if you know how to pick the right tool for the job.
如果你仔细搜索一下，会发现很多工具都能让你以代码的形式管理基础设施，包括 Chef、Puppet、Ansible、Pulumi、Terraform、OpenTofu、AWS、CloudFormation、Docker 和 Packer。那么，你应该选择哪一个呢？网上很多对比评测只是罗列了各个工具的通用特性，让人觉得用哪个都一样成功。理论上是这样，但实际上并非如此。这些工具之间存在着显著差异，如果你知道如何选择合适的工具，成功的几率就会大大提高。

This chapter will help you navigate the IaC space by introducing you to the four most common categories of IaC tools:
  · Ad hoc scripts (e.g., using a Bash script to deploy a server)
  · Configuration management tools (e.g., using Ansible to deploy a server)
  · Server templating tools (e.g., using Packer to build an image of a server)
  · Provisioning tools (e.g., using OpenTofu to deploy aserver)
本章将通过介绍四种最常见的 IaC 工具类别，帮助您更好地了解 IaC 领域：
· 即席脚本（例如，使用 Bash 脚本部署服务器）
· 配置管理工具（例如，使用 Ansible 部署服务器）
· 服务器模板工具（例如，使用 Packer 构建服务器镜像）
· 资源配置工具（例如，使用 OpenTofu 部署服务器）

You’ll work through examples to deploy the same infrastructure by using each of these approaches, which will allow you to see how different IaC categories perform across a variety of dimensions (e.g., verbosity, consistency, and scale), so that you can pick the right tool for the job.
您将通过示例学习如何使用每种方法部署相同的基础设施，从而了解不同 IaC 类别在各种维度（例如，冗长性、一致性和可扩展性）上的性能，以便选择合适的工具来完成任务。

Note that this chapter focuses on tools for managing infrastructure, whereas the next chapter focuses on tools for managing apps. These two domains have a lot of overlap, as you deploy infrastructure to run apps, and you may even deploy those apps by using IaC tools (you’ll see examples of just that in this chapter). However, as you’ll see, there are key differences between the infrastructure domain and the app domain. In the infrastructure domain, you use IaC tools such as OpenTofu to configure servers, load balancers, and networks. In the app domain you use orchestration tools such as Kubernetes to handle scheduling, auto scaling, auto healing, and service communication.
请注意，本章重点介绍用于管理基础设施的工具，而下一章重点介绍用于管理应用程序的工具。这两个领域有很多重叠之处，因为您部署基础设施是为了运行应用程序，您甚至可能使用 IaC 工具来部署这些应用程序（您将在本章中看到相关示例）。但是，正如您将看到的，基础设施领域和应用程序领域之间存在关键差异。在基础设施领域，您可以使用 OpenTofu 等 IaC 工具来配置服务器、负载均衡器和网络。在应用程序领域，您可以使用 Kubernetes 等编排工具来处理调度、自动扩展、自动修复和服务通信。

Before digging into the details of various IaC tools, it’s worth asking, why bother? Learning and adopting new tools has a cost, so what are the benefits of IaC that make this worthwhile? This is the focus of the next section.
在深入研究各种 IaC 工具的细节之前，值得思考一下：为什么要这样做？学习和采用新工具需要付出成本，那么 IaC 的优势是什么，才使得这些成本物有所值呢？这是下一节的重点。

The Benefits of IaC
When your infrastructure is defined as code, you can use a variety of software engineering practices to dramatically improve your software delivery processes, including the following:
IaC 的优势
当您的基础设施被定义为代码时，您可以运用各种软件工程实践来显著改进软件交付流程，包括以下几点：

	●Speed and safety
Instead of a person doing deployments manually, which is slow and error prone, defining your infrastructure as code allows a computer to carry out the deployment steps, which will be significantly faster and more reliable.
	●速度和安全性
将基础设施定义为代码，无需人工手动部署（这种方式速度慢且容易出错），而是让计算机执行部署步骤，速度更快、可靠性更高。

	●Documentation
If your infrastructure is defined as code, the state of your infrastructure is in source files that anyone can read, rather than locked away in a single person’s head. IaC acts as a form of documentation, allowing everyone in the organization to understand how things work.
	●文档
如果您的基础设施被定义为代码，那么基础设施的状态就存储在任何人都可以阅读的源文件中，而不是仅仅存在于某个人的脑海中。IaC 本身就是一种文档，它让组织中的每个人都能理解系统的工作原理。

	●Version control
Storing your IaC source files in version control (which you’ll do in Chapter 4) makes it easier to collaborate on your infrastructure, debug issues (e.g., by checking the version history to find out what changed), and to resolve issues (e.g., by reverting back to a previous version).
	●版本控制
将 IaC 源文件存储在版本控制系统中（您将在第 4 章中学习如何操作），可以更轻松地协作开发基础设施、调试问题（例如，通过查看版本历史记录来查找更改内容）以及解决问题（例如，通过回滚到以前的版本）。

	●Validation
If the state of your infrastructure is defined in code, for every single change, you can perform a code review, run a suite of automated tests, and pass the code through static analysis tools—all practices known to significantly reduce the chance of defects (you’ll see examples of all these practices in Chapter 4).
	●验证
如果您的基础架构状态以代码形式定义，那么对于每一次更改，您都可以执行代码审查、运行一系列自动化测试，并使用静态分析工具对代码进行检查——所有这些实践都能显著降低缺陷的发生概率（您将在第 4 章看到所有这些实践的示例）。

Self-service
If your infrastructure is defined in code, developers can kick off their own deployments instead of relying on others to do it.
自助服务
如果您的基础架构以代码形式定义，开发人员可以自行启动部署，而无需依赖他人。

Reuse
You can package your infrastructure into reusable modules so that instead of doing every deployment for every product in every environment from scratch, you can build on top of known, documented, battle-tested pieces.
重用
您可以将基础架构打包成可重用的模块，这样，您就不必为每个产品在每个环境中从头开始部署，而可以基于已知、有文档记录且经过实战检验的组件进行构建。

Happiness
One other important, and often overlooked, reason that you should use IaC is happiness. Manual deployments are repetitive and tedious. Most people resent this type of work, since it involves no creativity, no challenge, and no recognition. You could deploy code perfectly for months, and no one will take notice—until that one day when you mess it up. IaC offers a better alternative that allows computers to do what they do best (automation) and developers to do what they do best (creativity).
愉悦感
使用 IaC 的另一个重要且常被忽视的原因是愉悦感。手动部署重复且乏味。大多数人讨厌这种工作，因为它缺乏创造性、挑战性和认可。您可以完美地部署代码数月之久，却无人问津——直到有一天您搞砸了。 IaC 提供了一种更优的方案，它既能让计算机发挥其最擅长的自动化功能，又能让开发者专注于其最擅长的创造功能。

Now that you have a sense of why IaC is so valuable, in the following sections, you’ll explore the most common categories of IaC tools, starting with ad hoc scripts.
既然您已经了解了 IaC 的价值所在，接下来的章节将带您探索最常见的 IaC 工具类别，首先从即席脚本入手。

Ad Hoc Scripts
The first approach you might think of for managing your infrastructure as code is to use an ad hoc script. You take whatever task you were doing manually, break it into discrete steps, and use your favorite scripting language (e.g., Bash, Ruby, Python) to capture each of those steps in code. When you run that code, it can automate the process of creating infrastructure for you. The best way to understand this is to try it out, so let’s go through an example of an ad hoc script written in Bash, and then you’ll learn about the strengths and weaknesses of using scripts for managing infrastructure.
临时脚本
管理基础设施代码的首选方法之一就是使用临时脚本。您可以将之前手动执行的任务分解成若干步骤，然后使用您喜欢的脚本语言（例如 Bash、Ruby、Python）将每个步骤编写成代码。运行该代码后，它就能自动创建基础设施。理解这种方法的最佳途径是实际操作，因此让我们来看一个用 Bash 编写的临时脚本示例，然后您将了解使用脚本管理基础设施的优势和劣势。

Example: Deploy an EC2 Instance by Using a Bash Script

EXAMPLE CODE
As a reminder, you can find all the code examples in the book’s repo in GitHub.
示例：使用 Bash 脚本部署 EC2 实例
示例代码
提醒一下，您可以在本书的 GitHub 代码库中找到所有代码示例。

As an example, let’s create a Bash script that automates all the manual steps you did in Chapter 1 to deploy a simple Node.js app in AWS. Head into the fundamentals-of-devops folder you created in Chapter 1 to work through the examples in this book, and create a new subfolder for this chapter and the Bash script:
举个例子，我们来创建一个 Bash 脚本，自动执行你在第一章中为在 AWS 上部署一个简单的 Node.js 应用而手动完成的所有步骤。进入你在第一章中创建的 fundamentals-of-devops 文件夹，以便完成本书中的示例，然后为本章内容和 Bash 脚本创建一个新的子文件夹：

$ cd fundamentals-of-devops
$ mkdir -p ch2/bash

Copy the exact same user data script from Chapter 1 into a file called user-data.sh within the ch2/bash folder:
将第一章中的用户数据脚本复制到 ch2/bash 文件夹中名为 user-data.sh 的文件中：


If you’re not an expert in Bash syntax, all you have to know about this script is that it uses the AWS CLI to automate the exact steps you did manually in the AWS console in Chapter 1:

1 Create a security group.
2 Update the security group to allow inbound HTTP requests on port 80.
3 Look up the ID of the Amazon Linux AMI.
4 Deploy an EC2 instance that will run the Amazon Linux AMI from , on a t2.micro instance, with the security group from, the user data script from user-data.sh, and the Name tag setto sample-app.
5 Output the IDs of the security group and EC2 instance and the public IP of the EC2 instance.

1. 创建一个安全组。
2. 更新安全组，允许端口 80 上的入站 HTTP 请求。
3. 查找 Amazon Linux AMI 的 ID。
4. 部署一个 EC2 实例，该实例将运行来自 [此处应填写 Amazon Linux AMI 的 ID] 的 Amazon Linux AMI，实例类型为 t2.micro，安全组来自 [此处应填写安全组名称]，用户数据脚本来自 user-data.sh，名称标签设置为 sample-app。
5. 输出安全组 ID、EC2 实例 ID 以及 EC2 实例的公有 IP 地址。

WATCH OUT FOR SNAKES: THESE SIMPLIFIED EXAMPLES ARE FOR LEARNING,
NOT PRODUCTION
The examples in this chapter are still simplified for learning and not suitable for production usage, because of the security concerns and user data limitations explained in “Watch Out for Snakes: These Examples Have Several Problems”. You’ll see how to resolve these limitations in the next chapter.
小心蛇：这些简化示例仅供学习之用，
不适用于生产环境
本章中的示例仍然是为了学习而简化的，由于“小心蛇：这些示例存在一些问题”中解释的安全隐患和用户数据限制，不适用于生产环境。您将在下一章中了解如何解决这些限制。

If you want to run the script, you first need to give it execute permissions:
如果要运行该脚本，首先需要赋予其执行权限：
$ cd ch2/bash
$ chmod u+x deploy-ec2-instance.sh

Next, install the AWS CLI (minimum version 2.0), authenticate to AWS, and run the script as follows:
接下来，安装 AWS CLI（最低版本 2.0），对 AWS 进行身份验证，然后按如下方式运行脚本：
$ ./deploy-ec2-instance.sh
Instance ID = i-0335edfebd780886f
Security Group ID = sg-09251ea2fe2ab2828
Public IP = 52.15.237.52

After the script finishes, give the EC2 instance a minute or two to boot up and then try opening http://<Public IP> in your web browser, where <Public IP> is the IP address the script outputs at the end. You should see this:
脚本运行完毕后，请等待一两分钟让 EC2 实例启动，然后在浏览器中打开 http://<公有 IP 地址>，其中 <公有 IP 地址> 是脚本最后输出的 IP 地址。您应该会看到以下内容：

Hello, World!

Congrats, you are now running your app by using an ad hoc script!
恭喜，您现在已通过临时脚本运行您的应用程序！

GET YOUR HANDS DIRTY
Here are a few exercises you can try at home to go deeper:
What happens if you run the Bash script a second time? Why?
How do you change the script to run multiple EC2 instances?
动手实践
以下是一些您可以在家尝试的练习，以加深理解：
如果再次运行 Bash 脚本会发生什么？为什么？
如何修改脚本以运行多个 EC2 实例？

When you’re done experimenting with this script, you should manually undeploy the EC2 instance, as shown previously in Figure 1-9. This ensures that your account doesn’t start accumulating any unwanted charges.
完成脚本实验后，您应该手动取消部署 EC2 实例，如图 1-9 所示。这样可以确保您的账户不会产生任何不必要的费用。

You’ve now seen one way to manage your infrastructure as code. Well, sort of. This script, and most ad hoc scripts, have quite a few drawbacks in terms of using them to manage infrastructure, as discussed next.
您现在已经了解了一种以代码形式管理基础设施的方法。嗯，某种程度上来说是这样。正如接下来要讨论的，这个脚本以及大多数临时脚本在用于管理基础设施方面存在不少缺点。

How Ad Hoc Scripts Stack Up
临时脚本的性能对比
You can use certain criteria, which I’ll refer to as the IaC category criteria, to compare categories of IaC tools. In this section, I’ll flush out how ad hoc scripts stack up according to the IaC category criteria; in later sections, you’ll see how the other IaC categories perform along the same criteria, giving you a consistent way to compare the options. Here are the criteria:
您可以使用某些标准（我称之为 IaC 类别标准）来比较不同类型的 IaC 工具。在本节中，我将详细介绍临时脚本如何根据 IaC 类别标准进行性能对比；在后续章节中，您将看到其他 IaC 类别在相同标准下的表现，从而为您提供一种一致的比较方法。以下是这些标准：

CRUD
CRUD stands for create, read, update, and delete. To manage infrastructure as code, you typically need support for all four of these operations, whereas most ad hoc scripts handle only one: create. For example, this script can create a security group and EC2 instance, but if you run this script a second or third time, the script doesn’t know how to “read” the state of the world, so it has no awareness that the security group and EC2 instance already exist, and will always try to create new infrastructure from scratch.Likewise, this script has no built-in support for deleting any of the infrastructure it creates (which is why you had to manually terminate the EC2 instance). So while ad hoc scripts make it faster to create infrastructure, they don’t really help you manage it.
CRUD
CRUD 代表创建 (Create)、读取 (Read)、更新 (Update) 和删除 (Delete)。要管理基础设施即代码 (IaC as Code)，您通常需要支持所有这四种操作，而大多数临时脚本仅处理其中一种操作：创建。例如，这个脚本可以创建一个安全组和一个 EC2 实例，但如果您第二次或第三次运行此脚本，它就不知道如何“读取”当前状态，因此它无法感知到安全组和 EC2 实例已经存在，总是会尝试从头开始创建新的基础架构。同样，此脚本也没有内置的删除任何已创建基础架构的功能（这就是为什么您需要手动终止 EC2 实例的原因）。因此，虽然临时脚本可以加快创建基础架构的速度，但它们并不能真正帮助您管理基础架构。

Scale
Solving the CRUD problem in an ad hoc script for a single EC2 instance is hard enough, but a real architecture may contain hundreds of instances, plus databases, load balancers, networking configuration, and so on. There’s no easy way to scale up scripts to keep track of and manage so much infrastructure.
扩展性
在临时脚本中解决单个 EC2 实例的 CRUD 问题已经相当困难，但一个实际的架构可能包含数百个实例，以及数据库、负载均衡器、网络配置等等。要扩展脚本来跟踪和管理如此庞大的基础架构，并没有简单的方法。

Deployment strategies
In real-world architectures, you typically need to use various deployment strategies to roll out updates, such as rolling deployments and blue-green deployments (you’ll learn more about deployment strategies in Chapter 5). With ad hoc scripts, you’d have to write the logic for each deployment strategy from scratch.
部署策略
在实际架构中，您通常需要使用各种部署策略来推出更新，例如滚动部署和蓝绿部署（您将在第 5 章中了解更多关于部署策略的信息）。使用临时脚本，您必须从头开始为每种部署策略编写逻辑。

Idempotency
To manage infrastructure, you typically want code that is idempotent, which means it’s safe to rerun multiple times, as it will always produce the same effect as if you ran it once.Most ad hoc scripts are not idempotent. For example, if you ran the Bash script once, and it created the security group and EC2 instance, and then you ran the script again, it would try to create another security group and EC2 instance. This is probably not what you want, and it would also lead to an error, as you can’t have two security groups with the same name.
幂等性
为了管理基础架构，您通常需要幂等性的代码，这意味着可以安全地多次运行，因为它始终会产生与运行一次相同的效果。大多数临时脚本不具备幂等性。例如，如果您运行一次 Bash 脚本，它创建了安全组和 EC2 实例，然后您再次运行该脚本，它会尝试创建另一个安全组和 EC2 实例。这可能不是您想要的结果，并且还会导致错误，因为您不能拥有两个同名的安全组。

Consistency
The great thing about ad hoc scripts is that you can use any programming language you want, and you can write the code however you want. The terrible thing about ad hoc scripts is that you can use any programming language you want, and you can write the code however you want. I wrote the Bash script one way; you might write it another way; your coworker may choose a different language entirely. If you’ve ever had to maintain a large repository of ad hoc scripts, you know that it almost always devolves into a mess of unmaintainable spaghetti code. As you’ll see shortly, tools that are designed specifically for managing infrastructure as code often provide a single, idiomatic way to solve each problem, so your codebase tends to be more consistent and easier to maintain.
一致性
临时脚本的优点在于你可以使用任何你想要的编程语言，并且可以随心所欲地编写代码。但缺点也恰恰在于此。我用一种方式编写了 Bash 脚本；你可能用另一种方式编写；你的同事甚至可能选择完全不同的语言。如果你曾经维护过一个庞大的临时脚本库，你就会知道，它几乎总是会演变成一团难以维护的意大利面条式代码。正如你很快就会看到的，专门用于管理基础设施即代码的工具通常会为每个问题提供一种单一的、惯用的方法，因此你的代码库往往更加一致，也更容易维护。

Verbosity
The Bash script to launch a simple EC2 instance, plus the user data script, add up to around 80 lines of code—and that’s without the code for CRUD, deployment strategies, and idempotency. An ad hoc script that handles all these properly would be many times longer. And we’re talking about just one EC2 instance; your production infrastructure may include hundreds of instances, plus databases, load balancers, network configurations, and so on. The amount of custom code it takes to manage all this with ad hoc scripts quickly becomes untenable. As you’ll see shortly, tools designed specifically for managing infrastructure as code typically provide APIs that are more concise for accomplishing common infrastructure tasks.
冗长性
用于启动一个简单的 EC2 实例的 Bash 脚本，加上用户数据脚本，加起来大约有 80 行代码——这还不包括 CRUD 操作、部署策略和幂等性相关的代码。一个能够妥善处理所有这些问题的临时脚本会冗长得多。而且我们这里讨论的仅仅是一个 EC2 实例；您的生产基础设施可能包含数百个实例，以及数据库、负载均衡器、网络配置等等。使用临时脚本来管理所有这些所需的自定义代码量很快就会变得难以承受。正如您稍后将看到的，专门用于管理基础设施即代码的工具通常会提供更简洁的 API 来完成常见的基础设施任务。

Ad hoc scripts have always been, and will always be, a big part of software delivery. They are the glue and duct tape of the DevOps world. However, they are not the best choice as a primary tool for managing infrastructure as code.
临时脚本一直是软件交付的重要组成部分，而且将来也仍将如此。它们是 DevOps 世界中的粘合剂和万能胶带。然而，它们并非管理基础设施即代码的主要工具的最佳选择。

KEY TAKEAWAY 1
Ad hoc scripts are great for small, one-off tasks, but not for managing all your infrastructure as code.
要点一
临时脚本非常适合小型、一次性任务，但并不适合以代码形式管理所有基础设施。

If you’re going to be managing all your infrastructure as code, you should use an IaC tool that is purpose-built for the job, such as one of the ones discussed in the next several sections.
如果您要以代码形式管理所有基础设施，则应该使用专为此目的而设计的 IaC 工具，例如接下来几节中讨论的工具。

Configuration Management Tools
配置管理工具
After trying out ad hoc scripts and hitting all the issues mentioned in the previous section, the software industry moved on to configuration management tools, such as Chef, Puppet, and Ansible (full list). These tools first started to appear before cloud computing was ubiquitous, so they were originally designed to assume that someone else had done the work of setting up the hardware (e.g., your Ops team racked the servers in your own data center), and the primary purpose of these tools was to handle the software, including configuring the OS, installing dependencies, and deploying and updating apps.
在尝试了各种临时脚本并遇到了上一节中提到的所有问题之后，软件行业开始使用配置管理工具，例如 Chef、Puppet 和 Ansible（完整列表）。这些工具最初出现于云计算普及之前，因此它们的设计初衷是假设硬件的搭建工作已经由其他人完成（例如，您的运维团队在您自己的数据中心内架设了服务器），而这些工具的主要目的是处理软件，包括配置操作系统、安装依赖项以及部署和更新应用程序。

Each configuration management tool has you write code in a different domain-specific language (DSL). For example, with Chef, you write code in a DSL built on top of Ruby, whereas with Ansible, you write code in a DSL built on top of YAML. Once you’ve written the code, most configuration management tools work to update your servers to match the desired state in your code. To update your servers, configuration management tools rely on the following two items:
每种配置管理工具都要求您使用不同的领域特定语言 (DSL) 编写代码。例如，Chef 使用基于 Ruby 的 DSL 编写代码，而 Ansible 使用基于 YAML 的 DSL 编写代码。编写完代码后，大多数配置管理工具会更新服务器，使其与代码中设定的期望状态相匹配。为了更新服务器，配置管理工具依赖于以下两项：
● Management servers
You run one or more management servers (Chef Server, Puppet Server, or Ansible Automation Controller),2 which are responsible for communicating with the rest of your servers, tracking the state of those servers, providing a central UI and API to manage those servers, and running a reconciliation loop to continuously ensure that the configuration of each server matches your desired configuration.
● 管理服务器
您需要运行一个或多个管理服务器（Chef 服务器、Puppet 服务器或 Ansible 自动化控制器）²，它们负责与其余服务器通信、跟踪这些服务器的状态、提供用于管理这些服务器的中央 UI 和 API，并运行协调循环以持续确保每个服务器的配置与您期望的配置相匹配。

●Agents
Chef and Puppet require you to install custom agents (Chef Client and Puppet Agent) on each server, which are responsible for connecting to and authenticating with the management servers. You can configure the management servers to either push changes to these agents or to have the agents pull changes from the management servers. Ansible, on the other hand, pushes changes to your servers over SSH, which is preinstalled on most Linux/Unix servers by default (you’ll learn more about SSH in Chapter 7). Whether you rely on agents or SSH, this leads to a chicken-and-egg problem: to be able to configure your servers (with configuration management tools), you first have to configure your servers (install agents or set up SSH authentication). Solving this chicken-and-egg problem usually requires either manual intervention or additional tools.
● 代理
Chef 和 Puppet 要求您在每台服务器上安装自定义代理（Chef 客户端和 Puppet 代理），这些代理负责连接到管理服务器并进行身份验证。您可以配置管理服务器，使其将更改推送给这些代理，或者让代理从管理服务器拉取更改。另一方面，Ansible 通过 SSH 将更改推送至您的服务器，SSH 默认预装在大多数 Linux/Unix 服务器上（您将在第 7 章中了解更多关于 SSH 的信息）。无论你依赖代理还是 SSH，这都会引发一个先有鸡还是先有蛋的问题：要配置服务器（使用配置管理工具），你首先必须配置服务器（安装代理或设置 SSH 身份验证）。解决这个先有鸡还是先有蛋的问题通常需要人工干预或借助其他工具。

The best way to understand configuration management is to see it in action, so let’s go through an example of using Ansible to deploy and configure servers. Then you’ll see how configuration management tools stack up against the IaC category criteria.
理解配置管理的最佳方法是观察它的实际应用，所以让我们来看一个使用 Ansible 部署和配置服务器的示例。然后，您将了解配置管理工具如何符合 IaC 类别标准。

Example: Deploy an EC2 Instance by Using Ansible
To be able to use configuration management, you first need a server. This section will show you how to deploy an EC2 instance by using Ansible. Note that deploying and managing servers (hardware) is not really what configuration management tools were designed to do, but for spinning up a single server for learning and testing, Ansible is good enough.	
示例：使用 Ansible 部署 EC2 实例
要使用配置管理，首先需要一台服务器。本节将向您展示如何使用 Ansible 部署 EC2 实例。请注意，部署和管理服务器（硬件）并非配置管理工具的真正用途，但对于启动单个服务器进行学习和测试而言，Ansible 已经足够用了。

Create a new folder called ansible:
$ cd fundamentals-of-devops
$ mkdir -p ch2/ansible
$ cd ch2/ansible

Inside the Ansible folder, create an Ansible playbook called create_ec2_instances_playbook.yml, with the contents shown in Example 2-2.

An Ansible playbook specifies the hosts to run on, some variables, and then a list of tasks to execute on those hosts.
Each task runs a module, which is a unit of code that can execute various commands. The preceding playbook does the following:
Ansible playbook 指定要运行的主机、一些变量，以及要在这些主机上执行的任务列表。
每个任务运行一个模块，模块是一段可以执行各种命令的代码单元。前面的 playbook 执行以下操作：

1 Specify the hosts: The hosts entry specifies where this playbook will run. Most playbooks run on remote hosts (on servers you’re configuring), as you’ll see in the next section, but this playbook runs on localhost, as it is just making a series of API calls to AWS to deploy a server.
1. 指定主机：hosts 条目指定此 playbook 的运行位置。大多数 playbook 运行在远程主机（您正在配置的服务器上），您将在下一节中看到这一点，但此 playbook 运行在本地主机上，因为它只是向 AWS 发出一系列 API 调用来部署服务器。
2 Define variables: The vars block defines three variables used throughout the playbook: num_instances, which specifies the number of EC2 instances to create (default: 1); base_name, which specifies the name of all the resources created by this playbook (default: sample_app_ansible); and http_port, which specifies the port the instances should listen on for HTTP requests (default: 8080). In this chapter, you’ll use the default values for all these variables, but in Chapter 3, you’ll see how to override these variables.
2. 定义变量：vars 块定义了 playbook 中使用的三个变量：num_instances，指定要创建的 EC2 实例数量（默认值：1）；base_name，指定此 playbook 创建的所有资源的名称（默认值：sample_app_ansible）；以及 http_port，指定实例应监听 HTTP 请求的端口（默认值：8080）。在本章中，您将使用所有这些变量的默认值，但在第 3 章中，您将了解如何覆盖这些变量。
3 Create a security group: The first task in the playbook uses the amazon.aws.ec2_security_group module to create a security group in AWS. The preceding code configures this security group to allow inbound HTTP requests on http_port and inbound SSH requests on port 22. Note the use of Jinja templating syntax, such as {{ base_name }} and {{ http_port }}, to dynamically fill in the values of the variables defined in 1.
3. 创建安全组：playbook 中的第一个任务使用 amazon.aws.ec2_security_group 模块在 AWS 中创建一个安全组。前面的代码配置此安全组，允许通过 http_port 端口接收入站 HTTP 请求，并通过 22 端口接收入站 SSH 请求。请注意，这里使用了 Jinja 模板语法，例如 {{ base_name }} 和 {{ http_port }}，用于动态填充步骤 1 中定义的变量值。
4 Create an EC2 key pair: An EC2 key pair is a public/private key pair that can be used to authenticate to an EC2 instance over SSH.
4 创建 EC2 密钥对：EC2 密钥对是一个公钥/私钥对，可用于通过 SSH 对 EC2 实例进行身份验证。
5 Save the private key: Store the private key of the EC2 key pair locally in a file called {{ base_name }}.key, which with the default variable values will resolve to sample_app_ansible.key. You’ll use this private key in the next section to authenticate to the EC2 instance.
5 保存私钥：将 EC2 密钥对的私钥存储在本地名为 {{ base_name }}.key 的文件中，使用默认变量值，该文件将解析为 sample_app_ansible.key。您将在下一节中使用此私钥对 EC2 实例进行身份验证。
6 Look up the ID of the Amazon Linux AMI: Use the ec2_ami_info module to do the same lookup you saw in the Bash script with aws ec2 describe-images.
6 查找 Amazon Linux AMI 的 ID：使用 ec2_ami_info 模块执行与 Bash 脚本中使用 aws ec2 describe-images 命令相同的查找操作。
7 Create EC2 instances: Create one or more EC2 instances (based on the num_instances variable) that run Amazon Linux and use the security group and public key from the previous steps.
7. 创建 EC2 实例：创建一个或多个 EC2 实例（数量取决于 num_instances 变量），这些实例运行 Amazon Linux，并使用之前步骤中设置的安全组和公钥。
8 Tag the instance: This sets the Ansible tag on the instance to {{ base_name }}, which will default to sample_app_ansible.
You’ll use this tag in the next section.
8. 标记实例：此操作会将实例的 Ansible 标签设置为 {{ base_name }}，默认值为 sample_app_ansible。您将在下一节中使用此标签。

未完成

Server Templating Tools
An alternative to configuration management that has been growing in popularity recently is to use server templating tools, such as virtual machines (VMs) and containers.Instead of launching a bunch of servers and configuring them by running the same code on each one, the idea behind server templating tools is to create an image of a server that captures a self-contained “snapshot” of the entire filesystem. You can then use another IaC tool to install that image on your servers.
服务器模板工具
近年来，一种替代配置管理的方案——使用服务器模板工具（例如虚拟机 (VM) 和容器）——越来越受欢迎。与启动大量服务器并在每台服务器上运行相同代码进行配置不同，服务器模板工具的核心思想是创建一个服务器镜像，该镜像捕获了整个文件系统的独立“快照”。然后，您可以使用其他基础设施即代码 (IaC) 工具将该镜像安装到您的服务器上。

As shown in Figure 2-1, there are two types of tools for working with images.
如图 2-1 所示，处理图像的工具有两种类型。

Figure 2-1. The two main types of images: VMs (on the left) virtualize the hardware, whereas containers (on the right) virtualize only user space
图 2-1. 两种主要的镜像类型：虚拟机（左侧）虚拟化硬件，而容器（右侧）仅虚拟化用户空间

Virtual machines
These emulate an entire computer system, including the hardware. You run a hypervisor, such as VMware vSphere, VirtualBox, or Parallels (full list), to virtualize (simulate) the underlying CPU, memory, hard drive, and networking. The benefit is that any VM image that you run on top of the hypervisor can see only the virtualized hardware, so it’s fully isolated from the host machine and any other VM images, and it will run exactly the same way in all environments (e.g., your computer, a staging server, a production server). The drawback is that virtualizing all this hardware and running a totally separate OS for each VM incurs a lot of overhead in terms of CPU usage, memory usage, and startup time. You can define VM images as code by using tools such as Packer, which you typically use to create images for production servers, and Vagrant, which you typically use to create images for local development.注3
虚拟机
虚拟机模拟整个计算机系统，包括硬件。您需要运行虚拟机管理程序（例如 VMware vSphere、VirtualBox 或 Parallels（完整列表））来虚拟化（模拟）底层 CPU、内存、硬盘和网络。其优点在于，运行在虚拟机管理程序之上的任何虚拟机镜像都只能访问虚拟化的硬件，因此它与宿主机和其他虚拟机镜像完全隔离，并且在所有环境（例如，您的计算机、测试服务器、生产服务器）中都能以完全相同的方式运行。缺点是，虚拟化所有这些硬件并为每个虚拟机运行完全独立的操作系统会造成大量的 CPU 使用率、内存使用率和启动时间方面的开销。您可以使用 Packer 等工具将虚拟机镜像定义为代码。Packer 通常用于创建生产服务器镜像，而 Vagrant 通常用于创建本地开发镜像。 注3

Containers
These emulate the user space of an OS.注4 You run a container engine, such as Docker, Moby, or CRI-O (full list), to isolate processes, memory, mount points, and networking. The benefit is that any container you run on top of the container engine can see only its own user space, so it’s isolated from the host machine and other containers, and will run exactly the same way in all environments. The drawback is that all the containers running on a single server share that server’s OS kernel and hardware, so it’s more difficult to achieve the level of isolation and security you get with a VM.5 However, because the kernel and hardware are shared, your containers can boot up in milliseconds and have virtually no CPU or memory overhead. You can define container images as code by using tools such as Docker.
容器
容器模拟操作系统的用户空间。 注4  您需要运行容器引擎，例如 Docker、Moby 或 CRI-O（完整列表），以隔离进程、内存、挂载点和网络。其优点在于，运行在容器引擎之上的任何容器都只能访问自身的用户空间，因此它与宿主机和其他容器隔离，并且在所有环境中运行方式完全相同。缺点是，运行在同一台服务器上的所有容器共享该服务器的操作系统内核和硬件，因此难以达到虚拟机所能提供的隔离性和安全性。 然而，由于内核和硬件是共享的，因此您的容器可以在几毫秒内启动，并且几乎没有 CPU 或内存开销。您可以使用 Docker 等工具将容器镜像定义为代码。

You’ll go through an example of using container images with Docker in Chapter 3. In this section, let’s go through an example of using VM images with Packer. After that, you’ll see how server templating tools stack up against the IaC category criteria.
第三章会通过示例讲解如何使用 Docker 构建容器镜像。本节中，我们将通过示例讲解如何使用 Packer 构建虚拟机镜像。之后，我们将探讨服务器模板工具如何符合基础设施即代码 (IaC) 的标准。

Example: Create a VM Image by Using Packer
As an example, let’s take a look at using Packer to create a VM image for AWS called an AMI. First, create a folder called packer:
示例：使用 Packer 创建虚拟机镜像
我们以 Packer 为例，看看如何使用它为 AWS 创建一个名为 AMI 的虚拟机镜像。首先，创建一个名为 packer 的文件夹：


未完成


Conclusion
结论
You now understand how to manage your infrastructure as code. Instead of clicking around a web UI, which is tedious and error prone, you can automate the process, making if faster and more reliable. Moreover, whereas manual deployments always require someone at your company to do the busywork, with IaC, you can reuse code written by others. While learning, for example, you can reuse code from this book’s sample code repo in GitHub, and in production, you can reuse code from collections such as Ansible Galaxy, Docker Hub, OpenTofu Registry, and the Gruntwork Infrastructure as Code Library (full list).
现在您已经了解如何以代码形式管理基础设施。您无需再像以前那样在繁琐且容易出错的 Web 用户界面上点击操作，而是可以实现流程自动化，从而提高速度和可靠性。此外，手动部署总是需要公司里的某个人来做繁琐的工作，而使用 IaC，您可以重用其他人编写的代码。例如，在学习过程中，您可以重用本书在 GitHub 上的示例代码库中的代码；在生产环境中，您可以重用 Ansible Galaxy、Docker Hub、OpenTofu Registry 和 Gruntwork Infrastructure as Code Library（完整列表）等集合中的代码。

To help you pick an IaC tool, here are the six key takeaways from this chapter:
为了帮助您选择合适的 IaC 工具，以下是本章的六个关键要点：
● Ad hoc scripts are great for small, one-off tasks, but not for managing all your infrastructure as code.
● Configuration management tools are great for managing the configuration of servers, but not for deploying the servers themselves or other infrastructure.
● Server templating tools are great for managing the configuration of servers with immutable infrastructure practices.
● Provisioning tools are great for deploying and managing servers and infrastructure.
● You usually need to use multiple IaC tools together to manage your infrastructure.
● Adopting IaC requires more than just introducing a new tool or technology; it also requires changing the culture and processes of the team.
● 临时脚本非常适合小型、一次性任务，但不适合以代码形式管理所有基础设施。
● 配置管理工具非常适合管理服务器配置，但不适合部署服务器本身或其他基础设施。
● 服务器模板工具非常适合管理采用不可变基础设施实践的服务器配置。
● 配置工具非常适合部署和管理服务器及基础设施。
● 通常需要结合使用多个 IaC 工具来管理基础设施。
● 采用 IaC 不仅仅是引入新的工具或技术；它还需要改变团队的文化和流程。

If the job you’re doing is provisioning infrastructure, you’ll probably want to use a provisioning tool. If the job you’re doing is configuring servers, you’ll probably want to use a server templating or configuration management tool. And as most real-world software delivery setups require you to do multiple jobs, you’ll most likely have to combine several tools together (e.g., provisioning plus server templating).
如果你负责基础设施配置，你可能需要使用配置工具。如果你负责服务器配置，你可能需要使用服务器模板或配置管理工具。由于大多数实际的软件交付场景都需要你完成多项任务，你很可能需要将多个工具组合使用（例如，配置工具加服务器模板工具）。

It’s worth remembering that there is also a lot of variety within an IaC category; for example, there are big differences between Ansible and Chef within the configuration management category, and between OpenTofu and CloudFormation within the provisioning tool category. For a more detailed analysis, have a look at this comparison of Chef, Puppet, Ansible, Pulumi, CloudFormation, and Terraform/OpenTofu.
值得注意的是，即使在基础设施即代码 (IaC) 类别中，工具之间也存在很大的差异；例如，配置管理工具中的 Ansible 和 Chef 之间存在显著差异，配置工具中的 OpenTofu 和 CloudFormation 之间也存在显著差异。如需更详细的分析，请参阅 Chef、Puppet、Ansible、Pulumi、CloudFormation 和 Terraform/OpenTofu 的比较。

GOING DEEPER ON OPENTOFU/TERRAFORM
深入了解 OpenTofu/Terraform
Many of the examples in the rest of this book involve provisioning infrastructure using OpenTofu, so you may want to become more familiar with this toolset. The best way to do that, with apologies for a bit of self-promotion, is to grab a copy of my other book, Terraform: Up & Running (O’Reilly).
本书其余部分中的许多示例都涉及使用 OpenTofu 配置基础设施，因此您可能需要更熟悉这套工具。最好的方法是（恕我自荐一下）购买我的另一本书《Terraform：入门与实践》（O’Reilly 出版）。

Being able to use code to run a server is a huge advantage over managing it manually, but a single server is also a single point of failure. What if it crashes? What if the load exceeds the capacity of a single server? How do you roll out changes without downtime? These topics move us into the domain of orchestration tools and managing apps, which is the focus of Chapter 3.
能够使用代码运行服务器相比手动管理具有巨大的优势，但单台服务器也存在单点故障的风险。如果服务器崩溃了怎么办？如果负载超过了单台服务器的承载能力怎么办？如何在不停机的情况下部署变更？这些问题将我们带入编排工具和应用程序管理的领域，这也是第三章的重点。
——————————————————————————————————————————————————————————————————————————————————
注释：
#1 This is where the term bus factor comes from. Your team’s bus factor is the number of people you can lose (e.g., because they got hit by a bus, or perhaps something less dramatic, like they changed jobs) before you can no longer operate your business. You never want to have a bus factor of 1.
#1 这就是“巴士系数”的由来。团队的巴士系数是指在公司无法继续运营之前，你可以承受的最大人员流失量（例如，被车撞了，或者其他不太严重的情况，比如换工作）。巴士系数永远不应该为 1。

#2 Note that with Chef and Puppet, using a management server is the idiomatic approach, whereas with Ansible, the idiomatic approach is to use the Ansible client directly (e.g., from your own computer), and the Automation Controller is an optional, paid add-on.
#2 请注意，对于 Chef 和 Puppet，使用管理服务器是惯用方法；而对于 Ansible，惯用方法是直接使用 Ansible 客户端（例如，从你自己的电脑上），自动化控制器是一个可选的付费插件。

#3 Several new virtualization technologies have appeared in the last few years, including Firecracker and V8 isolates (full list), that offer different trade-offs in terms of security and overhead. As these technologies mature, they may be worth a deeper look.
#3 近年来出现了几种新的虚拟化技术，包括 Firecracker 和 V8 隔离区（完整列表），它们在安全性和开销方面各有优劣。随着这些技术的成熟，它们值得深入研究。

#4 On most modern operating systems, code runs in one of two “spaces”: kernel space or user space. Code running in kernel space has direct, unrestricted access to all the hardware. There are no security restrictions (i.e., you can execute any CPU instruction, access any part of the hard drive, write to any address in memory) or safety restrictions (e.g., a crash in kernel space will typically crash the entire computer), so kernel space is generally reserved for the lowest-level, most trusted functions of the OS (typically called the kernel). Code running in user space does not have any direct access to the hardware and must use APIs exposed by the OS kernel instead. These APIs can enforce security restrictions (e.g., user permissions) and safety (e.g., a crash in a user-space app typically affects only that app), so just about all application code runs in user space.
#4 在大多数现代操作系统中，代码运行在两个“空间”之一：内核空间或用户空间。运行在内核空间中的代码可以直接、不受限制地访问所有硬件。用户空间没有安全限制（例如，您可以执行任何 CPU 指令、访问硬盘的任何部分、写入内存中的任何地址）或安全性限制（例如，内核空间中的崩溃通常会导致整个计算机崩溃），因此内核空间通常保留给操作系统最底层、最受信任的功能（通常称为内核）。用户空间中运行的代码无法直接访问硬件，必须使用操作系统内核公开的 API。这些 API 可以强制执行安全限制（例如，用户权限）和安全性限制（例如，用户空间应用程序中的崩溃通常只会影响该应用程序本身），因此几乎所有应用程序代码都在用户空间中运行。

#5 As a general rule, containers provide isolation that’s good enough to prevent your own applications from accidentally interfering with one another, but if you need to run third-party applications (e.g., you’re building your own cloud provider) that might intentionally be performing malicious actions, you’ll want the increased isolation guarantees of a VM.
#5 一般而言，容器提供的隔离足以防止您自己的应用程序之间意外相互干扰，但如果您需要运行可能故意执行恶意操作的第三方应用程序（例如，您正在构建自己的云提供商），则需要虚拟机提供的更高隔离保证。

#6 OpenTofu is an open source fork of Terraform that was created after Terraform moved away from an open source license. I prefer to use open source tools whenever possible, so this book uses OpenTofu for example code, but most of the examples should work with Terraform as well.
#6 OpenTofu 是 Terraform 的一个开源分支，它是在 Terraform 放弃开源许可后创建的。我尽可能地倾向于使用开源工具，因此本书的示例代码使用了 OpenTofu，但大多数示例也应该适用于 Terraform。


*************************************************************************
# Chapter 3. How to Manage Your Apps by Using Orchestration Tools
第三章 如何使用编排工具管理您的应用程序
In Chapter 2, you learned how to manage your infrastructure as code. In this chapter, you’re going to shift your focus from managing infrastructure to managing apps.This brings us to the domain of orchestration tools, which are tools designed to handle the many requirements that are unique to running apps.
在第二章中，您学习了如何以代码形式管理基础设施。本章，我们将把重点从管理基础设施转移到管理应用程序。这就引出了编排工具的领域，这些工具旨在处理运行应用程序时特有的诸多需求。


For example, one requirement is figuring out how many copies of your app to run. Running a single copy of your app, as you did in the previous chapter, is fine for learning, and for some use cases, a single copy may be all you ever need. But if your business depends on that app, having just a single copy may cause problems, such as outages due to hardware issues (e.g., the server dies), outages due to software issues (e.g., a bug that causes your app to crash), and outages due to load (e.g., your app becomes so popular, it exceeds the capacity of a single server). In short, a single copy of your app is a single point of failure.
例如，其中一个需求是确定要运行多少个应用程序副本。像上一章那样运行单个应用程序副本对于学习来说是可以的，而且对于某些用例来说，单个副本可能就足够了。但是，如果您的业务依赖于该应用程序，那么只有一个副本可能会导致问题，例如硬件问题导致的故障（例如服务器崩溃）、软件问题导致的故障（例如导致应用程序崩溃的错误）以及负载过高导致的故障（例如应用程序访问量过大，超过了单个服务器的容量）。简而言之，应用程序的单个副本就是一个单点故障。

To run applications in production, you typically need multiple copies, called replicas, of your app.Some of the other requirements of running an app include automatically restarting it if it crashes, deploying more replicas when there is heavy load, balancing load across multiple replicas, communicating with other apps, and so on. If you search around, you’ll quickly find many orchestration tools that can handle these requirements for you, such as Kubernetes, OpenShift, EC2, Amazon Elastic Container Service (ECS), Nomad, AWS Lambda, Google Cloud Functions, and Azure Serverless. Which one should you use? How do these tools compare?
要在生产环境中运行应用程序，通常需要应用程序的多个副本，称为“副本”。运行应用程序的其他一些要求包括：崩溃后自动重启、负载过重时部署更多副本、在多个副本之间均衡负载、与其他应用程序通信等等。如果您稍加搜索，就会发现许多编排工具可以满足这些需求，例如 Kubernetes、OpenShift、EC2、Amazon Elastic Container Service (ECS)、Nomad、AWS Lambda、Google Cloud Functions 和 Azure Serverless。您应该使用哪一个？这些工具之间有何区别？

Most orchestration tools can be grouped into one of the following four categories: 
大多数编排工具可以归为以下四类：
● Server orchestration (e.g., use Ansible to deploy code onto a cluster of servers)
● 服务器编排（例如，使用 Ansible 将代码部署到服务器集群）
● VM orchestration (e.g., deploy VMs into an EC2 Auto Scaling group)
● 虚拟机编排（例如，将虚拟机部署到 EC2 自动扩展组）
● Container orchestration (e.g., deploy containers into a Kubernetes cluster)
● 容器编排（例如，将容器部署到 Kubernetes 集群）
● Serverless orchestration (e.g., deploy functions using AWS Lambda)
● 无服务器编排（例如，使用 AWS Lambda 部署函数）

To help you navigate the orchestration space, this chapter will walk you through each of these categories. Along the way, you’ll work through examples that deploy the same app by using each of these approaches, which will let you see how different orchestration approaches perform across a variety of dimensions (e.g., rolling out updates, load balancing, auto scaling, and auto healing), so that you can pick the right tool for the job. Let’s get started by understanding exactly what orchestration is and why it’s important.
为了帮助您更好地了解编排领域，本章将逐一介绍这些类别。在此过程中，您将通过示例学习如何使用每种方法部署同一个应用程序，从而了解不同编排方法在各个方面（例如，发布更新、负载均衡、自动扩展和自动修复）的性能表现，以便您选择合适的工具。让我们首先来了解一下什么是编排以及它为何如此重要。

An Introduction to Orchestration
编排简介
In the world of classical music, a conductor is responsible for orchestration: the conductor directs the orchestra, coordinating all the individual members to start or stop playing, to increase or decrease the tempo, and to play quieter or louder. In the world of software, an orchestration tool is responsible for orchestration: it directs software clusters, coordinating all the individual apps to start or stop, to increase or decrease the hardware resources available to them, and to increase or decrease the number of replicas.
在古典音乐领域，指挥负责编排：指挥指挥乐团，协调所有成员开始或停止演奏、加快或减慢速度、增强或减弱音量。在软件领域，编排工具负责编排：它指挥软件集群，协调所有应用程序的启动或停止、增加或减少可用的硬件资源、增加或减少副本数量。

These days, for many people, the term “orchestration” is associated with Kubernetes, but the underlying needs have been around since the first programmer ran the first app for others to use. Anyone running an app in production needs to solve most or all of the following core orchestration problems:
如今，对许多人来说，“编排”一词与 Kubernetes 紧密相关，但其根本需求早在第一位程序员运行第一个供他人使用的应用程序时就已存在。任何在生产环境中运行应用程序的人都需要解决以下大部分或全部核心编排问题：
● Deployment
You need a way to deploy one or more replicas of your app onto your servers and to periodically roll out updates to your replicas, ideally without your users experiencing downtime (known as a zero-downtime deployment).
● 部署
需要一种方法将应用程序的一个或多个副本部署到服务器上，并定期向这些副本推出更新，理想情况下，用户无需经历任何停机时间（称为零停机部署）。

● Scheduling
For each deployment, you need to decide which apps should run on which servers, ensuring that each app gets the resources (CPU, memory, disk space) it needs. This is known as scheduling. With some orchestration tools, you do the scheduling yourself, manually. Other orchestration tools provide a scheduler that can do it automatically, and this scheduler usually implements some sort of bin packing algorithm to try to use the resources available as efficiently as possible.
● 调度
对于每次部署，您需要决定哪些应用程序应该在哪些服务器上运行，确保每个应用程序都能获得所需的资源（CPU、内存、磁盘空间）。这称为调度。某些编排工具允许您手动进行调度。其他编排工具则提供可以自动执行调度的调度器，该调度器通常会实现某种装箱算法，以尽可能高效地利用可用资源。

● Rollback
If a problem occurs when rolling out an update, you need a way to roll back all replicas to a previous version.
● 回滚
如果在推出更新时出现问题，您需要一种方法将所有副本回滚到以前的版本。

● Auto scaling
As load goes up or down, you need a way to automatically scale your app up or down in response. With vertical scaling, you scale the resources available to your existing servers up or down, such as getting faster CPUs, more memory, or bigger hard drives. With horizontal scaling, you deploy more servers and/or more replicas of your app across your servers.
● 自动扩展
随着负载的增加或减少，您需要一种方法来自动扩展或缩减应用程序的规模。通过垂直扩展，您可以扩展或缩减现有服务器的可用资源，例如获取更快的 CPU、更多内存或更大的硬盘驱动器。通过横向扩展，您可以在服务器上部署更多服务器和/或更多应用程序副本。

● Auto healing
You need something to monitor your apps, detect whether they are not healthy (i.e., the app is not responding correctly or at all), and to automatically restart or replace unhealthy apps or servers.
● 自动修复
需要某种机制来监控您的应用程序，检测它们是否运行正常（例如，应用程序是否响应不正确或完全无响应），并自动重启或替换运行不正常的应用程序或服务器。

● Load balancing
If you are running multiple replicas of your app, you may need a way to distribute traffic across all those replicas.
● 负载均衡
如果您运行应用程序的多个副本，则可能需要一种方法将流量分配到所有这些副本上。

● Configuration
If you have multiple environments, you need a way to configure the app differently in each environment (e.g., use different domain names or different memory settings in dev, stage, and prod).
● 配置
如果您有多个环境，则需要一种方法来在每个环境中对应用程序进行不同的配置（例如，在开发、测试和生产环境中使用不同的域名或不同的内存设置）。

● Secrets management
You may need a way to securely pass sensitive configuration data to your apps (e.g., passwords, API keys).
● 密钥管理
您可能需要一种方法来安全地将敏感配置数据（例如，密码、API 密钥）传递给您的应用程序。 
	
● Service communication
If you are running multiple apps, you may need to give them a way to communicate with one another, including a way to find out how to connect to other apps (service discovery), and ways to control and monitor that communication, including authentication, authorization, encryption, error handling, and observability (service mesh).
● 服务通信
如果您运行多个应用程序，则可能需要为它们提供相互通信的方式，包括查找如何连接到其他应用程序的方法（服务发现），以及控制和监控这些通信的方法，例如身份验证、授权、加密、错误处理和可观测性（服务网格）。

● Disk management
If your app stores data on a hard drive, then as you deploy replicas of your app, you need to ensure that the right hard drives end up with the right replicas.
● 磁盘管理
如果您的应用程序将数据存储在硬盘驱动器上，那么在部署应用程序副本时，您需要确保正确的硬盘驱动器最终与正确的副本关联。

Over the years, dozens of approaches have been used to solve each of these problems. In the pre-cloud era, since every on-prem deployment was different, most companies wrote their own bespoke solutions, typically consisting of gluing together various scripts and tools to solve each problem. Nowadays, the industry is starting to standardize around four broad types of solutions: server orchestration, VM orchestration, container orchestration, and serverless orchestration. The following sections dive into each of these, starting with server orchestration.
多年来，人们已经尝试了数十种方法来解决这些问题。在云计算时代之前，由于每个本地部署都各不相同，大多数公司都编写了自己的定制解决方案，通常是将各种脚本和工具拼凑在一起来解决每个问题。如今，业界开始围绕四大类解决方案进行标准化：服务器编排、虚拟机编排、容器编排和无服务器编排。以下章节将逐一深入探讨这些解决方案，首先从服务器编排开始。

Server Orchestration
The original approach used in the pre-cloud era, and one that, for better or worse, is still fairly common today, is to do the following:
● Set up a bunch of servers.
● Deploy your apps across the servers.
● When you need to roll out changes, update the servers in place.
服务器编排
云计算时代之前常用的原始方法，无论好坏，至今仍然相当普遍，具体步骤如下：
● 设置一批服务器。
● 将应用程序部署到这些服务器上。
● 当需要进行更改时，直接更新服务器上的相应配置。

I’ve seen companies use a variety of tools for implementing this approach, including configuration management tools (e.g., Chef, Puppet, and Ansible, as you saw in Chapter 2), specialized deployment scripts (e.g., Capistrano, Deployer, Mina; full list), and, perhaps most common of all, ad hoc scripts.
我见过许多公司使用各种工具来实现这种方法，包括配置管理工具（例如，您在第二章中看到的 Chef、Puppet 和 Ansible）、专用部署脚本（例如，Capistrano、Deployer 和 Mina；完整列表），以及最常见的即席脚本。

Because this approach predates the cloud era, it also predates most attempts at creating standardized tooling for it, and I’m not aware of any single, commonly accepted name for it. Most people would just refer to it as “deployment tooling,” as deployment was the primary focus (as opposed to auto scaling, auto healing, and service discovery). For the purposes of this book, I’ll refer to it as server orchestration, to disambiguate it from the newer orchestration approaches you’ll see later, such as VM and container orchestration.
由于这种方法早于云计算时代，因此也早于大多数为其创建标准化工具的尝试，而且我目前还没有一个被广泛接受的名称。大多数人会将其称为“部署工具”，因为部署是其主要关注点（而不是自动扩展、自动修复和服务发现）。为了本书的论述，我将它称为服务器编排，以区别于您稍后将看到的更新的编排方法，例如虚拟机编排和容器编排。

KEY TAKEAWAY 1
Server orchestration is an older, mutable infrastructure approach utilizing a fixed set of servers that you maintain and update in place.
要点一：
服务器编排是一种较早的、可变的基础架构方法，它使用一组固定的服务器，需要您进行维护和就地更新。

To get a feel for server orchestration, let’s use Ansible. In Chapter 2, you saw how to deploy a single EC2 instance using Ansible. In this section, you’ll see how to use Ansible to deploy multiple instances to run the sample app, configure nginx to distribute load across the instances, and roll out updates across the instances without downtime.
为了更好地理解服务器编排，我们来使用 Ansible。在第二章中，您学习了如何使用 Ansible 部署单个 EC2 实例。在本节中，您将学习如何使用 Ansible 部署多个实例来运行示例应用程序，配置 nginx 以在各个实例之间分配负载，以及如何在不停机的情况下跨实例推出更新。

Example: Deploy an App Securely and Reliably by Using Ansible

The first thing you need for server orchestration is a bunch of servers. You can spin up several EC2 instances by reusing the Ansible playbook and inventory file you created in Chapter 2.1 Head into the fundamentals-of-devops folder you’ve been using to work through the examples in this book, create a new ch3/ansible subfolder, and copy into that subfolder create_ec2_instances_playbook.yml and inventory.aws_ec2.yml from Chapter 2:
服务器编排的第一步是需要一些服务器。您可以重用在第 2.1 章中创建的 Ansible playbook 和 inventory 文件来启动多个 EC2 实例。进入您用于学习本书示例的 fundamentals-of-devops 文件夹，创建一个新的 ch3/ansible 子文件夹，并将第 2 章中的 create_ec2_instances_playbook.yml 和 inventory.aws_ec2.yml 文件复制到该子文件夹中：
$ cd fundamentals-of-devops
$ mkdir -p ch3/ansible
$ cp ch2/ansible/create_ec2_instances_playbook.yml ch3/ansible/
$ cp ch2/ansible/inventory.aws_ec2.yml ch3/ansible/
$ cd ch3/ansible

This time, you’ll override the default variables in the playbook to create multiple EC2 instances with different names and ports. To do this, create a file called sampleapp- vars.yml with the contents shown in Example 3-1.
这次，您需要覆盖 playbook 中的默认变量，以创建多个具有不同名称和端口的 EC2 实例。为此，请创建一个名为 sampleapp-vars.yml 的文件，并添加示例 3-1 中所示的内容。

This variables file will create three servers named sample_app_instances that allow incoming HTTP requests on port 8080. To run the playbook, authenticate to AWS, and run the ansible-playbook command, adding the --extra-vars flag to pass in the variables file:


VM Orchestration
The idea with VM orchestration is to do the following:
● Create VM images that have your apps and all their dependencies fully installed and configured.
● Deploy the VM images across a cluster of servers.
● Scale the number of servers up or down depending on your needs.
● When you need to deploy an update, create new VM images, deploy those onto new servers, and then undeploy the old servers.
虚拟机编排
虚拟机编排的理念是：
● 创建虚拟机镜像，其中包含您的应用程序及其所有依赖项的完整安装和配置。
● 将虚拟机镜像部署到服务器集群中。
● 根据需要扩展或缩减服务器数量。
● 当需要部署更新时，创建新的虚拟机镜像，将其部署到新服务器上，然后卸载旧服务器上的镜像。

This is a slightly more modern approach that works best with cloud providers such as AWS, Google Cloud, and Azure, where the servers are all virtual servers, so you can spin up new ones and tear down old ones in minutes. That said, you can also use virtualization on prem with tools such as VMware, Citrix, or Microsoft Hyper-V. The example in this section will be of VM orchestration on AWS, but the concepts apply to most VM orchestration tools, whether in the cloud or on prem.
这是一种稍微现代一些的方法，最适合与 AWS、Google Cloud 和 Azure 等云服务提供商配合使用。在这些云平台上，服务器都是虚拟服务器，因此您可以在几分钟内快速创建新服务器并关闭旧服务器。当然，您也可以在本地使用 VMware、Citrix 或 Microsoft Hyper-V 等工具进行虚拟化。本节的示例将以 AWS 上的虚拟机编排为例，但其中的概念适用于大多数虚拟机编排工具，无论是在云端还是在本地。

KEY TAKEAWAY 2
VM orchestration is an immutable infrastructure approach that deploys and manages VM images across virtualized servers.
要点二
虚拟机编排是一种不可变的基础架构方法，用于跨虚拟化服务器部署和管理虚拟机镜像。

Let’s go through an example of VM orchestration. You will learn how to build a VM image using Packer, deploy the VM image across multiple instances, configure a load balancer to distribute load across the instances, and roll out updates across the instances without downtime.
我们来看一个虚拟机编排的例子。您将学习如何使用 Packer 构建虚拟机镜像，将虚拟机镜像部署到多个实例，配置负载均衡器以在实例间分配负载，以及在不停机的情况下向所有实例推出更新。

Example: Build a VM Image by Using Packer
Head into the fundamentals-of-devops folder you created in Chapter 1 to work through the examples in this book, and create a new subfolder for the Packer code:
示例：使用 Packer 构建虚拟机镜像
进入您在第一章创建的 fundratives-of-devops 文件夹，以便完成本书中的示例，并创建一个新的子文件夹用于存放 Packer 代码：
$ cd fundamentals-of-devops
$ mkdir -p ch3/packer
Copy the Packer template and install-node.sh script you created in Chapter 2 into the new ch3/packer folder:
$ cp ch2/packer/sample-app.pkr.hcl ch3/packer/
$ cp ch2/packer/install-node.sh ch3/packer/

You should also copy app.js (the sample app) and app.config.js (the PM2 configuration file) from the Ansible example in the previous section into the
ch3/packer/sample-app folder:
您还应该将上一节 Ansible 示例中的 app.js（示例应用程序）和 app.config.js（PM2 配置文件）复制到以下位置：
ch3/packer/sample-app 文件夹：
$ mkdir -p ch3/packer/sample-app
$ cp ch3/ansible/roles/sample-app/files/app*.js ch3/packer/sample-app




Container Orchestration
With container orchestration, you do the following:
● Create container images that have your apps and all their dependencies fully installed and configured.
● Deploy the container images across a cluster of servers, with potentially multiple containers per server, packed in as efficiently as possible (bin packing).
● Automatically scale the number of servers or the number of containers up or down, depending on load.
● When you need to deploy an update, create new container images, deploy them into the cluster, and then undeploy the old containers.
容器编排
通过容器编排，您可以执行以下操作：
● 创建容器镜像，其中包含您的应用程序及其所有依赖项的完整安装和配置。
● 将容器镜像部署到服务器集群中，每个服务器可以部署多个容器，并尽可能高效地打包（打包）。
● 根据负载自动扩展或缩减服务器数量或容器数量。
● 当需要部署更新时，创建新的容器镜像，将其部署到集群中，然后卸载旧容器。

Although containers have been around for decades, container orchestration started to explode in popularity around 2013, with the emergence of Docker, a tool for building, running, and sharing containers, and Kubernetes, a container orchestration tool. The reason for this popularity is that containers and container orchestration offer advantages over VMs and VM orchestration:
尽管容器技术已经存在数十年，但容器编排技术直到 2013 年左右才开始迅速普及，这主要得益于 Docker（一种用于构建、运行和共享容器的工具）和 Kubernetes（一种容器编排工具）的出现。容器和容器编排技术之所以如此受欢迎，是因为它们相比虚拟机和虚拟机编排技术具有诸多优势：
Speed
Containers typically build faster than VMs, especially with caching, and container orchestration tools typically deploy faster than VMs. While the build-and-deploy cycle with VMs takes 5–30 minutes, it’s just 1–5 minutes with containers.
速度
容器的构建速度通常比虚拟机快，尤其是在使用缓存的情况下；容器编排工具的部署速度也通常比虚拟机快。虚拟机的构建和部署周期需要 5-30 分钟，而容器只需 1-5 分钟。

Efficiency
Most container orchestration tools have a built-in scheduler to decide which servers in your cluster should run which containers, using bin packing algorithms to use the available resources as efficiently as possible.注释2
效率
大多数容器编排工具都内置了调度器，用于决定集群中哪些服务器应该运行哪些容器，并使用装箱算法来尽可能高效地利用可用资源。注释2

Portability
Containers and container orchestration are supported just about everywhere, including on prem and in all the major cloud providers. Moreover, the most popular container tools, Docker and Kubernetes, are both open source.
可移植性
容器和容器编排几乎在所有地方都受支持，包括本地部署和所有主流云服务提供商。此外，最流行的容器工具 Docker 和 Kubernetes 都是开源的。

Local development
Running VMs for local development is relatively rare, as VM images are fairly heavyweight (large file sizes, slow boot times, CPU and memory overhead), and there is no practical way to run most VM orchestration tools locally (e.g., there’s no way to deploy an AWS ASG on your own computer). On the other hand, running containers in your local development environment is fairly common, as containers are more lightweight (smaller file sizes, faster boot, less CPU and memory overhead), and it’s easy to run container orchestration tools locally (you’ll see an example of running Kubernetes locally shortly).
本地开发
本地开发中使用虚拟机的情况相对较少，因为虚拟机镜像相当庞大（文件体积大、启动时间长、CPU 和内存开销大），而且大多数虚拟机编排工具在本地运行也没有实际可行的方法（例如，无法在自己的计算机上部署 AWS ASG）。另一方面，在本地开发环境中运行容器相当普遍，因为容器更轻量级（文件更小、启动更快、CPU 和内存占用更少），而且在本地运行容器编排工具也很容易（稍后您将看到在本地运行 Kubernetes 的示例）。

Functionality
Container orchestration tools solved more orchestration problems out of the box than VM orchestration tools. For example, Kubernetes has built-in solutions for deployment, updates, auto scaling, auto healing, configuration, secrets management, service discovery, and disk management.
功能
容器编排工具比虚拟机编排工具开箱即用地解决了更多编排问题。例如，Kubernetes 内置了部署、更新、自动扩缩容、自动修复、配置、密钥管理、服务发现和磁盘管理等解决方案。

KEY TAKEAWAY 3
Container orchestration is an immutable infrastructure approach that deploys and manages container images across a cluster of servers.
要点三
容器编排是一种不可变的基础设施方法，用于在服务器集群中部署和管理容器镜像。

You saw the wide variety of container tools you can choose from in Chapter 2, such as Docker, Moby, and CRI-O. You also have a wide variety of orchestration tools to choose from, including Kubernetes, Nomad, Amazon ECS, and OpenShift (full list). The most popular, by far, are Docker and Kubernetes—so much so that their names are nearly synonymous with containers and container orchestration, respectively—so that’s what we’ll focus on in this book.
您在第二章中已经了解了各种各样的容器工具，例如 Docker、Moby 和 CRI-O。此外，您还可以选择多种编排工具，包括 Kubernetes、Nomad、Amazon ECS 和 OpenShift（完整列表）。其中最流行的当属 Docker 和 Kubernetes——它们的名字几乎分别成了容器和容器编排的代名词——因此，本书将重点介绍它们。

In this section, you’ll learn to use Docker, followed by Kubernetes, and finally, you’ll learn to use Docker and Kubernetes in AWS. Let’s get into it!
在本节中，您将学习如何使用 Docker，然后是 Kubernetes，最后是如何在 AWS 中使用 Docker 和 Kubernetes。让我们开始吧！

Example: A Crash Course on Docker
First, install Docker Desktop (minimum version 4.0). Once it’s installed, you should have the docker command available on your command line. You can use the docker run command to run Docker images locally:
示例：Docker 速成教程
首先，安装 Docker Desktop（最低版本 4.0）。安装完成后，您应该可以在命令行中使用 docker 命令。您可以使用 docker run 命令在本地运行 Docker 镜像：



`-t` 标志指定 Docker 镜像的标签（名称）。这段代码将镜像名称设置为 `sample-app`，版本设置为`v1`。之后，如果您对示例应用程序进行更改，您将能够构建一个新的 Docker 镜像并为其指定一个新的版本，例如 `v2`。末尾的点号 (.) 指定前目录（应该是包含您的 Dockerfile 的文件夹）作为构建上下文，这用于告诉Docker 构建过程中可以访问的文件集。构建完成后，您可以使用 `docker run` 命令运行您的新镜像（使用 `-it` 和 `--init` 标志以确保Ctrl-C 正常工作）：


Congrats, you now know how to run a web app locally using Docker! However, while using docker run directly is fine for local testing and learning, it’s not the way you’d run Dockerized apps in production. For that, you typically want to use a container orchestration tool such as Kubernetes, which is our next topic.

CLEANING UP CONTAINERS
Every time you use docker run and exit, you are leaving behind containers, which take up disk space. You can clean them up with the docker rm <CONTAINER_ID> command, where CONTAINER_ID is the ID of the container from the docker ps output. Alternatively, you can include the --rm flag in your docker run command to have Docker automatically clean up when you exit the container.
清理容器
每次使用 `docker run` 并退出后，都会留下一些容器，这些容器会占用磁盘空间。您可以使用 `docker rm <CONTAINER_ID>` 命令清理它们，其中 `CONTAINER_ID` 是 `docker ps` 输出中显示的容器 ID。或者，您也可以在 `docker run` 命令中添加 `--rm` 标志，让 Docker 在退出容器时自动清理。

Example: Deploy a Dockerized App with Kubernetes
Kubernetes (sometimes referred to as K8S) is a container orchestration tool, which means it’s a platform for running and managing containers on your servers, including scheduling, auto healing, auto scaling, load balancing, and more. Under the hood, Kubernetes consists of two main pieces, as shown in Figure 3-2.
示例：使用 Kubernetes 部署 Docker 化应用
Kubernetes（有时也称为 K8S）是一种容器编排工具，它是一个用于在服务器上运行和管理容器的平台，包括调度、自动修复、自动扩展、负载均衡等功能。Kubernetes 的底层主要由两部分组成，如图 3-2 所示。

Figure 3-2. The Kubernetes architecture consists of a control plane and worker nodes
图 3-2. Kubernetes 架构由控制平面和工作节点组成

A Kubernetes cluster consists of the following two pieces:
Kubernetes 集群由以下两部分组成：
Control plane
This is responsible for managing the Kubernetes cluster. It is
the “brains” of the operation, responsible for storing the
state of the cluster, monitoring containers, and coordinating
actions across the cluster. It also runs the API server, which
provides an API you can use from command-line tools (e.g.,
kubectl), web UIs (e.g., the Kubernetes Dashboard), and IaC
tools (e.g., OpenTofu) to control what’s happening in the
cluster.
控制平面
控制平面负责管理 Kubernetes 集群。它是集群运行的“大脑”，负责存储集群状态、监控容器以及协调集群内的各种操作。它还运行 API 服务器，该服务器提供 API，您可以通过命令行工具（例如 kubectl）、Web UI（例如 Kubernetes Dashboard）和 IaC 工具（例如 OpenTofu）来控制集群的运行。

Worker nodes
These are the servers used to run your container workloads.The worker nodes are entirely managed by the control plane, which tells each worker node which containers it should run.

工作节点
这些是用于运行容器工作负载的服务器。工作节点完全由控制平面管理，控制平面会告诉每个工作节点应该运行哪些容器。

Kubernetes is open source, and one of its strengths is that you can run it anywhere: in any cloud, on prem, and even on your personal computer. A little later in this chapter, you’ll run Kubernetes in the cloud (in AWS), but for now, let’s start small and run it locally. This is easy to do if you installed a relatively recent version of Docker Desktop, as it has Kubernetes built in. Open Docker Desktop’s preferences, and you should see Kubernetes in the menu, as shown in Figure 3-3.
Kubernetes 是开源的，它的优势之一在于可以随处运行：任何云平台、本地环境，甚至个人电脑。本章稍后会介绍如何在云端（AWS）运行 Kubernetes，但现在，我们先从本地运行开始。如果您安装了较新版本的 Docker Desktop，这将很容易实现，因为它内置了 Kubernetes。打开 Docker Desktop 的首选项，您应该会在菜单中看到 Kubernetes，如图 3-3 所示。

Figure 3-3. Enable Kubernetes on Docker Desktop

Check the Enable Kubernetes checkbox, click “Apply & restart,” and wait a few minutes for that to complete.
选中“启用 Kubernetes”复选框，点击“应用并重启”，然后等待几分钟完成。

In the meantime, install kubectl (minimum version 1.30), which is the command-line tool for interacting with Kubernetes. To use kubectl, you must first update its configuration file, which lives in $HOME/.kube/config (the .kube folder of your home directory), to tell it which Kubernetes cluster to connect to. Conveniently, when you enable Kubernetes in Docker Desktop, it updates this config file for you, adding a docker-desktop entry to it, so all you need to do is tell kubectl to use this configuration as follows:
同时，安装 kubectl（最低版本 1.30），它是与 Kubernetes 交互的命令行工具。要使用 kubectl，您必须先更新其配置文件，该文件位于 $HOME/.kube/config（您主目录下的 .kube 文件夹）中，以指定要连接的 Kubernetes 集群。方便的是，当您在 Docker Desktop 中启用 Kubernetes 时，它会自动更新此配置文件，并添加一个 docker-desktop 条目，因此您只需告诉 kubectl 使用此配置即可，如下所示：



The get nodes command shows you information about all the nodes in your cluster. Since you’re running Kubernetes locally, your computer is the only node, and it’s running the control plane and acting as a worker node. You’re now ready to run some Docker containers.
`get nodes` 命令会显示集群中所有节点的信息。由于您是在本地运行 Kubernetes，因此您的计算机是唯一的节点，它运行着控制平面并充当工作节点。现在，您可以运行一些 Docker 容器了。

To deploy something in Kubernetes, you create Kubernetes objects, which are persistent entities you write to the Kubernetes cluster (via the API server) that record your intent (e.g., your intent to have specific Docker images running). The cluster runs a reconciliation loop, which continuously checks the objects you stored in it and works to make the state of the cluster match your intent.
要在 Kubernetes 中部署某些内容，您需要创建 Kubernetes 对象。这些对象是持久实体，您需要将其写入 Kubernetes 集群（通过 API 服务器），以记录您的意图（例如，运行特定 Docker 镜像的意图）。集群会运行一个协调循环，持续检查您存储的对象，并使集群状态与您的意图相匹配。

Many types of Kubernetes objects are available. The one we’ll use to deploy your sample app is a Kubernetes Deployment, which is a declarative way to manage an application in Kubernetes. The Deployment allows you to declare which Docker images to run, how many copies of them to run (replicas), a variety of settings for those images (e.g., CPU, memory, port numbers, environment variables), and so on, and the Deployment will then work to ensure that the requirements you declared are always met.
Kubernetes 对象有很多种类型。我们将使用 Kubernetes Deployment 来部署您的示例应用程序。Deployment 是一种声明式方式，用于在 Kubernetes 中管理应用程序。部署功能允许您声明要运行的 Docker 镜像、要运行的镜像副本数量（副本数）、这些镜像的各种设置（例如 CPU、内存、端口号、环境变量等），部署功能随后会确保始终满足您声明的要求。

One way to interact with Kubernetes is to create YAML files to define your Kubernetes objects, and to use the kubectl apply command to submit those objects to the cluster.
与 Kubernetes 交互的一种方法是创建 YAML 文件来定义 Kubernetes 对象，并使用 `kubectl apply` 命令将这些对象提交到集群。

Create a new folder called kubernetes to store these YAML files:
创建一个名为 `kubernetes` 的新文件夹来存储这些 YAML 文件：



This YAML file gives you a lot of functionality for just ~20 lines of code: 
这个 YAML 文件仅用大约 20 行代码就提供了强大的功能：
1 The kind keyword specifies that this Kubernetes object is a Deployment.
1 `kind` 关键字指定此 Kubernetes 对象为 Deployment。

2 Every Kubernetes object includes metadata that can be used to identify and target that object in API calls. Kubernetes makes heavy use of metadata and labels to keep the system highly flexible and loosely coupled. The preceding code sets the name of the Deployment to sample-app-deployment.
每个 Kubernetes 对象都包含元数据，可用于在 API 调用中识别和定位该对象。Kubernetes 大量使用元数据和标签来保持系统的高度灵活性和松耦合性。前面的代码将 Deployment 的名称设置为 `sample-app-deployment`。

3 The Deployment will run three replicas.
该 Deployment 将运行三个副本。

4 This is the Pod template—the blueprint—that defines what this Deployment will deploy and manage. It’s similar to the launch template you saw with AWS ASGs. In Kubernetes, instead of deploying one container at a time, you deploy Pods, which are groups of containers meant to be deployed together. For example, you could have a Pod with one container to run a web app (e.g., the sample app) and another container that gathers metrics on the web app and sends them to a central service (e.g., Datadog). So this template block allows you to configure your Pods, specifying what container(s) to run, the ports to use, environment variables to set, and so on.
这是 Pod 模板（蓝图），它定义了此 Deployment 将部署和管理的内容。它类似于您在 AWS ASG 中看到的启动模板。在 Kubernetes 中，您不是一次部署一个容器，而是部署 Pod，Pod 是一组旨在一起部署的容器。例如，您可以创建一个 Pod，其中包含一个用于运行 Web 应用程序（例如示例应用程序）的容器，以及另一个用于收集 Web 应用程序指标并将其发送到中央服务（例如 Datadog）的容器。此模板块允许您配置 Pod，指定要运行的容器、要使用的端口、要设置的环境变量等等。

5 Templates can be used separately from Deployments, so they have separate metadata that allows you to identify and target that template in API calls (this is another example of Kubernetes trying to be highly flexible and decoupled). This code sets the app label to sample-app-pods.
模板可以独立于 Deployment 使用，因此它们拥有独立的元数据，允许您在 API 调用中识别并定位该模板（这是 Kubernetes 力求高度灵活和解耦的另一个例子）。此代码将应用标签设置为 sample-app-pods。

6 Inside the Pod template, you define one or more containers to run in that Pod.
在 Pod 模板中，您可以定义一个或多个要在该 Pod 中运行的容器。

7 This example configures just a single container to run, called sample-app.
此示例仅配置一个名为 sample-app 的容器以运行。

8 Configure the container to run the Docker image you built earlier.
配置容器以运行您之前构建的 Docker 镜像。

9 This tells Kubernetes that the Docker image listens for requests on port 8080.
这会告诉 Kubernetes 该 Docker 镜像监听 8080 端口上的请求。

10 Set environment variables for the container. The code sets the NODE_ENV environment variable to production.
为容器设置环境变量。此代码将 NODE_ENV 环境变量设置为 production。

11 Since Deployments and templates can be defined completely separately, you need to specify a selector to tell the Deployment which Pod to target (this is yet another example of Kubernetes trying to be flexible and decoupled).
由于部署和模板可以完全分开定义，因此需要指定一个选择器来告诉部署要定位到哪个 Pod（这是 Kubernetes 试图做到灵活和解耦的另一个例子）。

Use the kubectl apply command to apply your Deployment configuration:
$ kubectl apply -f sample-app-deployment.yml
deployment.apps/sample-app-deployment created




















*************************************************************************
# Chapter 4. How to Version,Build, and Test Your Code
*************************************************************************
# Chapter 5. How to Set Up Continuous Integration and Continuous Delivery
*************************************************************************
# Chapter 6. How to Work with Multiple Teams and Environments
*************************************************************************
# Chapter 7. How to Set Up Networking
*************************************************************************
# Chapter 8. How to Secure Communication and Storage
*************************************************************************
# Chapter 9. How to Store Data
*************************************************************************
# Chapter 10. How to Monitor Your Systems
*************************************************************************
# Chapter 11. The Future of DevOps and Software Delivery 
*************************************************************************

